import { newLww } from "@/State/scoped/backups/lww"
import { SourceType } from "@/State/scoped/common"
import { Satoshi } from "@/lib/types/units"
import { SourcesState } from "@/State/scoped/backups/sources/state"
import { SourceMetadata } from "@/State/scoped/backups/sources/metadata/types"
import { NprofileSourceDocV0 } from "@/State/scoped/backups/sources/schema"
import { GetUserOperationsResponse, UserOperation, UserOperations, UserOperationType } from "@/Api/pub/autogenerated/ts/types"
import { IdentityDocV0 } from "@/State/scoped/backups/identity/schema"
import { IdentityState } from "@/State/scoped/backups/identity/slice"
import { generateNewKeyPair } from "@/Api/helpers"



export const TEST_RELAY_URL = "wss://test-relay.lightning.pub";

export const createTestSourceDoc = (sourceLpk: string, sourceId: string): NprofileSourceDocV0 => {
	const keys = generateNewKeyPair();
	return {
		doc_type: "doc/shockwallet/source_",
		source_id: sourceId,
		schema_rev: 0,
		label: newLww(null),
		relays: { [TEST_RELAY_URL]: { clock: { v: 0, by: "test" }, present: true } },
		bridgeUrl: newLww(null),
		admin_token: newLww(null),
		is_ndebit_discoverable: newLww(false),
		deleted: newLww(false,),
		type: SourceType.NPROFILE_SOURCE,
		lpk: sourceLpk,
		keys: {
			publicKey: keys.publicKey,
			privateKey: keys.privateKey
		},
		created_at: Date.now()
	}
}



export const createTestSourceMetadata = (sourceLpk: string, sourceId: string): SourceMetadata => ({
	lastSeenAtMs: 500_000,
	balance: 0 as Satoshi,
	maxWithdrable: 0 as Satoshi,
	id: sourceId,
	lpk: sourceLpk
})




export type TestSource = {
	id: string;
	lpk: string;
	dirty?: boolean;
	docOverride?: Partial<NprofileSourceDocV0>;
	metaOverride?: Partial<SourceMetadata>;
};

type HistoryState = SourcesState["history"];

type GetStateOpts = {
	beaconStaleMs?: number;
	historyOverride?: Partial<HistoryState>;
};

export const getPreloadedSourcesState = (
	sources: TestSource[],
	opts: GetStateOpts = {}
): SourcesState => {
	const ids: string[] = [];
	const docEntities: SourcesState["docs"]["entities"] = {};
	const metaEntities: SourcesState["metadata"]["entities"] = {};

	for (const s of sources) {
		const { id, lpk, dirty = true, docOverride, metaOverride } = s;
		ids.push(id);

		docEntities[id] = {
			draft: { ...createTestSourceDoc(lpk, id), ...(docOverride ?? {}) },
			dirty,
		};

		metaEntities[id] = {
			...createTestSourceMetadata(lpk, id),
			...(metaOverride ?? {}),
		};
	}

	const historyDefault: HistoryState = {
		ops: { entities: {}, ids: [] },
		bySource: {},
		newPaymentsCount: 0,
	};

	return {
		docs: { entities: docEntities, ids },
		metadata: {
			entities: metaEntities,
			ids: [...ids],
			beaconStaleMs: opts.beaconStaleMs ?? 150_000,
		},
		history: { ...historyDefault, ...(opts.historyOverride ?? {}) },
		beaconProbe: { entities: {}, ids: [] }
	};
};


export type GenSource = { id: string; lpk: string };
export function generateSources(count: number, _prefix = "src", lpk?: string): GenSource[] {


	return Array.from({ length: count }, () => {

		const keys = generateNewKeyPair();
		const keysLpk = generateNewKeyPair();
		return {
			id: `${keysLpk.publicKey}-${keys.publicKey}`,
			lpk: lpk ?? keysLpk.publicKey,
		}
	});
}

export const createTestIdentitydoc = (pubkey: string, favouriteSourceId?: string): IdentityDocV0 => ({
	doc_type: "doc/shockwallet/identity_",
	favorite_source_id: newLww(favouriteSourceId ?? null, "me"),
	identity_pubkey: pubkey,
	schema_rev: 0,
	created_at: Date.now()
})
export const getPreloadedIdentityState = (pubkey: string, favouriteSourceId?: string): IdentityState => {
	return {
		dirty: true,
		draft: createTestIdentitydoc(pubkey, favouriteSourceId)
	}
}





type OpsOK = { status: "OK" } & GetUserOperationsResponse;







export function makeOps(kind: UserOperationType, n: number, startId = 1, startTs = 1): UserOperation[] {
	return Array.from({ length: n }, (_, i) => ({
		amount: 1, confirmed: true, identifier: `${kind}-${startId + i}`,
		inbound: kind.includes("INCOMING"), internal: false, network_fee: 0,
		operationId: `${kind}-op-${startId + i}`, paidAtUnix: startTs + i,
		service_fee: 0, tx_hash: `${kind}-tx-${startId + i}`, type: kind,
	}));
}


export function makeOpsPage(spec: {
	inInv?: number; inTx?: number; inU2U?: number;
	outInv?: number; outTx?: number; outU2U?: number;
	idBase?: number; tsBase?: number;
}): OpsOK {
	const sz = { inInv: 0, inTx: 0, inU2U: 0, outInv: 0, outTx: 0, outU2U: 0, ...spec };
	const mkGroup = (ops: UserOperation[]): UserOperations => ({
		fromIndex: { id: 0, ts: 0 },
		operations: ops,
		toIndex: ops.length
			? {
				id: parseInt(ops!.at(-1)!.operationId.split("-").pop() || "0", 10),
				ts: ops.at(-1)!.paidAtUnix
			}
			: { id: 0, ts: 0 },

	});
	const idBase = spec.idBase ?? 1;
	const tsBase = spec.tsBase ?? 1;

	const latestIncomingInvoiceOperations = mkGroup(makeOps(UserOperationType.INCOMING_INVOICE, sz.inInv, idBase, tsBase));
	const latestIncomingTxOperations = mkGroup(makeOps(UserOperationType.INCOMING_TX, sz.inTx, idBase, tsBase));
	const latestIncomingUserToUserPayemnts = mkGroup(makeOps(UserOperationType.INCOMING_USER_TO_USER, sz.inU2U, idBase, tsBase));
	const latestOutgoingInvoiceOperations = mkGroup(makeOps(UserOperationType.OUTGOING_INVOICE, sz.outInv, idBase, tsBase));
	const latestOutgoingTxOperations = mkGroup(makeOps(UserOperationType.OUTGOING_TX, sz.outTx, idBase, tsBase));
	const latestOutgoingUserToUserPayemnts = mkGroup(makeOps(UserOperationType.OUTGOING_USER_TO_USER, sz.outU2U, idBase, tsBase));

	return {
		status: "OK",
		latestIncomingInvoiceOperations,
		latestIncomingTxOperations,
		latestIncomingUserToUserPayemnts,
		latestOutgoingInvoiceOperations,
		latestOutgoingTxOperations,
		latestOutgoingUserToUserPayemnts,
	};
}
