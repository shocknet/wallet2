import type { NostrKeyPair } from "@/Api/nostrHandler";
import type { NostrClientParams } from "@/Api/pub/autogenerated/ts/nostr_client";
import type { NostrRequest } from "@/Api/pub/autogenerated/ts/nostr_transport";
import { vi } from "vitest";

type SentFrame = {
	relays: string[];
	to: string;
	message: string;
	keys: { publicKey: string; privateKey: string };
};

export type NostrMockControls = {
	frames: SentFrame[];
	clear(): void;
	// reply to a specific captured frame (index) with an OK payload
	replyOk(i: number, payload?: object): void;
	// reply to last frame
	replyLastOk(payload?: object): void;

	// reply for last occurence of a specific rpc
	replayForRpc(rpcName: string, payload: object): void;
	replyError(i: number, reason?: string): void;
};

export function mockNostrLayer(): NostrMockControls {

	const frames: SentFrame[] = [];

	// Relay onEvent/ onDisconnect callbacks captured from ClientsCluster.SyncClusterRelays(...)
	let onEvent: ((evt: any) => void) | null = null;



	vi.doMock("@/Api/nostrHandler", () => {
		class FakeRelayCluster {
			async addRelays(
				_relaysSettings: any,
				onEvt: (e: any) => void,
				_onDisc: (r: string) => void
			) {
				onEvent = onEvt;

			}
			async resetrelays() {
				frames.length = 0;
				onEvent = null;

			}
			addBeaconListener(_cb: (b: any) => void) {
				return () => { };
			}
			Send(relays: string[], to: string, message: string, keys: NostrKeyPair) {
				frames.push({ relays, to, message, keys });
			}
			async SendNip69(_relays: string[], _to: string, _data: any, _keys: any) {
				return { status: "OK" };
			}
		}

		return { default: FakeRelayCluster };
	});

	vi.doMock("@/Api/pub/autogenerated/ts/nostr_client", () => {
		return {
			default: (
				params: NostrClientParams,
				send: (to: string, message: NostrRequest) => Promise<any>,
				subscribe: (to: string, message: NostrRequest, cb: (res: any) => void) => void
			) => {

				return new Proxy(
					{},
					{
						get(_, propKey: string) {

							/*
								Resolving a promise with this proxy causes the resolver to assume
								that we are resolving with another promise. In effect, awaiting
								the origianl promise never finishes.

								That's because the proxy returns a function for every propKey, including
								"then". So we assert here that this proxy is not a promise by making "then"
								return undefined.
							*/
							if (propKey === "then") return undefined;

							return async (requestOrCb: any) => {
								const auth = await params.retrieveNostrAdminAuth()


								if (propKey.includes("GetLive")) {
									const nostrRequest: NostrRequest = {}
									subscribe(params.pubDestination, { rpcName: propKey, authIdentifier: auth!, ...nostrRequest }, (data) => {
										if (data.status === 'ERROR' && typeof data.reason === 'string') return requestOrCb(data)
										if (data.status === 'OK') {
											const result = data
											return requestOrCb({ status: 'OK', ...result })

										}
										return requestOrCb({ status: 'ERROR', reason: 'invalid response' })
									})
								} else {
									const nostrRequest: NostrRequest = {}
									nostrRequest.body = requestOrCb

									const data = await send(params.pubDestination, { rpcName: propKey, authIdentifier: auth!, ...nostrRequest })
									if (data.status === 'ERROR' && typeof data.reason === 'string') return data
									if (data.status === 'OK') {
										return data
									}
									return { status: 'ERROR', reason: 'invalid response' }
								}


							};
						},
					},
				);
			},
		};
	});


	function deliverFromFrame(i: number, payload: any) {
		if (!onEvent) throw new Error("Relay onEvent not registered yet (client not initialized?)");
		const f = frames[i];
		if (!f) throw new Error(`No frame at index ${i}`);
		const msg = JSON.parse(f.message);
		const requestId = msg.requestId ?? msg.rpcName;


		const event = {
			pub: f.to,
			to: f.keys.publicKey,
			content: JSON.stringify({ requestId, ...payload }),
		};
		onEvent(event);
	}

	const controls: NostrMockControls = {
		frames,
		clear() {
			frames.length = 0;
		},
		replyOk(i: number, payload: object = {}) {
			deliverFromFrame(i, { status: "OK", ...payload });
		},
		replyLastOk(payload: object = {}) {
			if (frames.length === 0) throw new Error("No frames to reply to");
			controls.replyOk(frames.length - 1, payload);
		},
		replayForRpc(rpcName: string, payload: object) {
			const idx = frames.map(f => JSON.parse(f.message).rpcName).lastIndexOf(rpcName);
			if (idx < 0) throw new Error(`No frame with rpcName=${rpcName}`);
			controls.replyOk(idx, payload);
		},
		replyError(i: number, reason = "boom") {
			deliverFromFrame(i, { status: "ERROR", reason });
		},
	};
	return controls
}


