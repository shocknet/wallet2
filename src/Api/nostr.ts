import dLogger from "./helpers/debugLog";
import { BeaconUpdate, getPool, TransportPool, type NostrKeyPair } from "./nostrHandler";
import type NewNostrClientType from './pub/autogenerated/ts/nostr_client'
import { NostrRequest } from "./pub/autogenerated/ts/nostr_transport";
import { NofferData } from "@shocknet/clink-sdk";
import { Event, Filter } from "nostr-tools";
import { parseNprofile } from "@/lib/nprofile";
export type NostrEvent = {
	id: string
	pub: string
	content: string
	kind: number
	to: string
}

type ShardsInfo = { total: number; parts: (string | null)[] };

type NostrCallbackSingle = {
	startedAtMillis: number,
	timeout: ReturnType<typeof setTimeout>
	type: "single"
	message: NostrRequest,
	paused?: true,
	to: string,
	f: (res: any) => void
}

type NostrCallbackStream = {
	startedAtMillis: number,
	type: "stream"
	message: NostrRequest,
	to: string,
	f: (res: any) => void
}

type NostrCallback = NostrCallbackSingle | NostrCallbackStream;

export type Client = ReturnType<typeof NewNostrClientType>



const RPC_SINGLE_TIMEOUT_MS = 8_000;
const RETRY_UNSAFE = new Set(["PayAddress", "PayInvoice"]);




export class ClientsCluster {
	private pool: TransportPool;

	private clients: Record<string, NostrClient> = {};
	private tempClients: Record<string, NostrClient> = {};

	private shards: Record<string, ShardsInfo> = {};
	private inflight = new Map<string, Promise<Client>>();

	private logger = dLogger.withContext({ component: "cluster" })

	lifecycle: LifecycleCoordinator;

	private log = dLogger.withContext({ component: "nostr-clients" });

	constructor() {
		this.pool = getPool();
		this.pool.events.on("nostrEvent", (e) => this.onRelayEvent(e));
		this.lifecycle = new LifecycleCoordinator(this, this.pool)
	}

	getPool() {
		return this.pool;
	}

	getAllClients() {
		return Object.values(this.clients);
	}

	getClientById(id: string) {
		return this.clients[id];
	}



	onRelayEvent = (event: NostrEvent) => {
		const res = this.handleEventContent(event.content)
		if (!res) {
			return
		}
		const e = { ...event, parsedData: res }
		for (const key in this.clients) {
			const c = this.clients[key]
			if (c.onEvent(e)) {
				return
			}
		}
		for (const key in this.tempClients) {
			const c = this.tempClients[key]
			if (c.onEvent(e)) {
				return
			}
		}
		this.logger.info("no client found for", { data: { reqId: res.requestId } });
	}

	handleEventContent = (content: string) => {
		const res = JSON.parse(content)
		if (!res.shardsId) {
			return res as { requestId: string }
		}
		const shard = res as { part: string, index: number, totalShards: number, shardsId: string }
		let existingShards = this.shards[shard.shardsId]
		if (!existingShards) {
			existingShards = {
				total: shard.totalShards,
				parts: new Array(shard.totalShards).fill(null)
			}
			this.shards[shard.shardsId] = existingShards
		}
		existingShards.parts[shard.index] = shard.part
		if (existingShards.parts.every(p => p !== null)) {
			const fullContent = existingShards.parts.join('')
			delete this.shards[shard.shardsId]
			const parsed = JSON.parse(fullContent) as { requestId: string }
			return parsed
		}
		return null
	}


	async getClient(
		nProfile: { pubkey: string; relays?: string[] } | string,
		keys: NostrKeyPair,
		opts?: { temp?: boolean }
	): Promise<Client> {
		const parsed = typeof nProfile === "string" ? parseNprofile(nProfile) : nProfile;
		const { pubkey: lpk, relays } = parsed;

		if (!relays || relays.length === 0) throw new Error("cannot create client if no relays are provided");

		const store = opts?.temp ? this.tempClients : this.clients;
		const key = `${lpk}-${keys.publicKey}`;


		if (store[key]) {
			await this.pool.syncRelays({ relays, lpk, keys });
			return store[key].Get();
		}


		const existing = this.inflight.get(key);
		if (existing) return existing;

		const p = (async () => {
			await this.pool.syncRelays({ relays, lpk, keys });

			const nostrClient = await NostrClient.create(lpk, keys, relays, this.pool);
			store[key] = nostrClient;

			this.log.info("client-created", { data: { lpk, id: nostrClient.getId() } });
			return nostrClient.Get();
		})();

		this.inflight.set(key, p);
		try {
			return await p;
		} finally {
			this.inflight.delete(key);
		}
	}

	pauseSinglesOnBackground() {
		for (const c of Object.values(this.clients)) c.pauseOrFailSinglesOnBackground();
		for (const c of Object.values(this.tempClients)) c.pauseOrFailSinglesOnBackground();
	}

	async resumePausedSingles() {
		await Promise.allSettled([
			...Object.values(this.clients).map(c => c.resumePausedSingles()),
			...Object.values(this.tempClients).map(c => c.resumePausedSingles()),
		]);
	}


	async reset() {

		this.getAllClients().forEach((c) => c.disconnectCalls("identity-switch"));
		this.clients = {};
		this.tempClients = {};
		this.inflight.clear();
		this.shards = {};

		this.pool.reset();
		this.pool.events.on("nostrEvent", (e) => this.onRelayEvent(e));
	}
}

export class NostrClient {
	private clientId = makeId(16);
	private client: Client;

	clientCbs = new Map<string, NostrCallback>;

	private lpk: string;
	private relays: string[];
	settings: NostrKeyPair;

	latestResponseAtMillis = 0;
	latestHealthReqAtMillis = 0;

	private pool: TransportPool;

	constructor(
		lpk: string,
		settings: NostrKeyPair,
		relays: string[],
		pool: TransportPool,
		NewNostrClient: typeof NewNostrClientType
	) {
		this.lpk = lpk;
		this.settings = settings;
		this.relays = relays;
		this.pool = pool;

		this.client = NewNostrClient(
			{
				retrieveNostrUserAuth: async () => this.settings.publicKey,
				retrieveNostrAdminAuth: async () => this.settings.publicKey,
				retrieveNostrMetricsAuth: async () => this.settings.publicKey,
				retrieveNostrGuestWithPubAuth: async () => this.settings.publicKey,
				pubDestination: this.lpk,
			},
			this.clientSend,
			this.clientSub
		);
	}

	static async create(pubDestination: string, settings: NostrKeyPair, relays: string[], transport: TransportPool) {
		const { default: NewNostrClient } = await import("@/Api/pub/autogenerated/ts/nostr_client");
		return new NostrClient(pubDestination, settings, relays, transport, NewNostrClient);
	}

	getId = () => this.clientId;
	getLpk = () => this.lpk;
	getRelays = () => this.relays;
	Get = () => this.client;

	getClientState = () => {
		return {
			latestResponseAtMillis: this.latestResponseAtMillis,
			latestHealthReqAtMillis: this.latestHealthReqAtMillis,
		}
	}


	onEvent = (event: NostrEvent & { parsedData?: { requestId: string } }) => {
		const res = event.parsedData ?? (JSON.parse(event.content) as { requestId: string });

		if (event.pub !== this.lpk) return false;
		if (event.to !== this.settings.publicKey) return false;

		const cb = this.clientCbs.get(res.requestId);
		if (!cb) return false;

		cb.f(res);
		this.latestResponseAtMillis = Date.now();

		if (cb.type === "single") {
			clearTimeout(cb.timeout);
			this.clientCbs.delete(res.requestId);
		}
		return true;
	};


	private async ensureReadyForSend() {
		await this.pool.syncRelays({
			relays: this.relays,
			lpk: this.lpk,
			keys: this.settings
		});
	}

	private failClientCb(reqId: string, reason: string) {
		const cb = this.clientCbs.get(reqId);
		if (!cb) return;
		if (cb.type === "single") {
			clearTimeout(cb.timeout);
		}
		try {
			cb.f({ status: "ERROR", reason });
		} finally {
			this.clientCbs.delete(reqId);
		}
	}

	clientSend = async (to: string, message: NostrRequest): Promise<any> => {
		if (!message.requestId) message.requestId = makeId(16);
		const reqId = message.requestId;
		if (this.clientCbs.has(reqId)) throw new Error("request was already sent");

		const ret = new Promise(resolve => {
			const timeout = setTimeout(() => {
				if (message.rpcName === "PayInvoice" || message.rpcName === "PayAddress") return;
				this.failClientCb(reqId, "Request timed out");
			}, RPC_SINGLE_TIMEOUT_MS);

			const nostrCallback: NostrCallbackSingle = {
				type: "single",
				startedAtMillis: Date.now(),
				message,
				to,
				f: (response) => {
					resolve(response);
				},
				timeout
			};

			this.clientCbs.set(reqId, nostrCallback);
		});

		try {
			// Ensure at least one of the relays this client uses is connected
			// and has commited this client's keys into the rpc subscription
			await this.ensureReadyForSend();

			// If we couldn't send at all fail the cb right away
			await this.pool.send(this.relays, to, JSON.stringify(message), this.settings);

			return ret;
		} catch {
			// If send fails, fail promise deterministically
			this.failClientCb(reqId, "send failed");
			return ret;
		}
	};



	clientSub = (to: string, message: NostrRequest, cb: (res: any) => void): void => {
		if (!message.requestId) message.requestId = message.rpcName;
		const reqId = message.requestId;
		if (!reqId) throw new Error("invalid sub");

		if (this.clientCbs.has(reqId)) {
			return;
		}

		const nostrCallback: NostrCallbackStream = {
			startedAtMillis: Date.now(),
			type: "stream",
			message,
			f: (response: any) => {
				this.latestResponseAtMillis = Date.now();
				cb(response);
			},
			to
		};
		this.clientCbs.set(reqId, nostrCallback);

		this.ensureReadyForSend()
			.then(() => this.pool.send(this.relays, to, JSON.stringify(message), this.settings))
			.catch(() => this.failClientCb(reqId, "send failed"));
	};

	removeStreamSub = (reqId: string) => {
		const cb = this.clientCbs.get(reqId);

		if (cb && cb.type === "stream") {
			this.clientCbs.delete(reqId);
		}
	}



	pauseOrFailSinglesOnBackground() {
		const entries = [...this.clientCbs.entries()];
		for (const [_, cb] of entries) {
			if (cb.type !== "single") continue;

			const rpcName = cb.message.rpcName || "";
			const safe = !RETRY_UNSAFE.has(rpcName);

			if (safe) {
				cb.paused = true;
				clearTimeout(cb.timeout);
			}
		}
	}

	async resumePausedSingles() {
		for (const [id, cb] of this.clientCbs.entries()) {
			if (cb.type !== "single" || !cb.paused) continue;

			cb.startedAtMillis = Date.now();
			cb.paused = undefined;

			const timeout = setTimeout(() => {
				this.failClientCb(id, "Request timed out");
			}, RPC_SINGLE_TIMEOUT_MS);
			cb.timeout = timeout;
			try {
				await this.ensureReadyForSend();
				await this.pool.send(this.relays, cb.to, JSON.stringify(cb.message), this.settings);
			} catch {
				this.failClientCb(id, "send failed");
			}
		}
	}


	disconnectCalls(reason?: string) {
		for (const cb of this.clientCbs.values()) {
			if (cb.type === "single") {
				clearTimeout(cb.timeout);
			}
			cb.f({ status: "ERROR", reason: reason ?? "nostr connection timeout" });
		}
		this.latestResponseAtMillis = 0;
		this.latestHealthReqAtMillis = 0;
		this.clientCbs.clear();
	}
}

class LifecycleCoordinator {
	private desiredActive = true;
	private actualActive = true;
	private running: Promise<void> | null = null;

	private epoch = 0;

	private log = dLogger.withContext({ component: "nostr-lifecycle" });

	constructor(
		private cluster: ClientsCluster,
		private pool: TransportPool,
	) { }

	setDesiredActive(isActive: boolean) {
		this.desiredActive = isActive;
		this.epoch++;
		this.kick();
	}

	private kick() {
		if (this.running) return;
		this.running = this.run().finally(() => {
			this.running = null;
			// If another state change happened while we were running, loop again
			if (this.actualActive !== this.desiredActive) this.kick();
		});
	}

	private async run() {
		while (this.actualActive !== this.desiredActive) {
			const myEpoch = this.epoch;

			if (!this.desiredActive) {
				this.toBackground();
			} else {
				await this.toForeground(myEpoch);
			}
		}
	}
	toBackground() {
		this.cluster.pauseSinglesOnBackground();
		this.pool.pause();
		this.actualActive = false;
	}

	private async toForeground(myEpoch: number) {
		this.pool.resume();

		// if a background happened while we were resuming, abort
		if (myEpoch !== this.epoch) return;

		await this.cluster.resumePausedSingles();

		if (myEpoch !== this.epoch) return;

		this.actualActive = true;
	}
}



let cluster: ClientsCluster | null = null;
export const getCluster = () => (cluster ??= new ClientsCluster());
export type GetNostrClientNprofileArgs = { pubkey: string, relays?: string[] } | string;

export const getNostrClient = async (
	nProfile: GetNostrClientNprofileArgs,
	keys: NostrKeyPair,
	temp?: boolean
): Promise<Client> => getCluster().getClient(nProfile, keys, { temp });

export const getAllNostrClients = () => getCluster().getAllClients();

export const getClientById = (id: string) => getCluster().getClientById(id);

export const resetClientsCluster = async () => getCluster().reset();

export const subToBeacons = (cb: (beaconUpdate: BeaconUpdate) => void) =>
	getCluster().getPool().events.on("beacon", cb);

export const sendNip69 = async (noffer: { relay: string; pubkey: string }, data: NofferData, keys: NostrKeyPair) =>
	getCluster().getPool().sendNip69([noffer.relay], noffer.pubkey, data, keys);


export const appTag = "shockwallet"


export const getNip78Event = async (pubkey: string, relays: string[], dTag = appTag) => {
	if (relays.length === 0) return null;
	return getCluster().getPool().get(relays, { kinds: [30078], "#d": [dTag], authors: [pubkey] });
};

export const newNip78Event = (data: string, pubkey: string, dTag = appTag) => ({
	content: data,
	created_at: Math.floor(Date.now() / 1000),
	kind: 30078,
	tags: [["d", dTag]],
	pubkey,
});

export const newSourceDocEvent = (data: string, pubkey: string, dTag = appTag) => ({
	content: data,
	created_at: Math.floor(Date.now() / 1000),
	kind: 30079,
	tags: [["d", dTag]],
	pubkey,
});



export const subToNip78DocEvents = (relays: string[], filters: Filter[], onEvent: (e: Event) => Promise<void>) =>
	getCluster().getPool().subscribeMany(relays, filters, { onevent: (e: Event) => void onEvent(e) });



export const fetchNostrUserMetadataEvent = async (pubKey: string, relays: string[]) =>
	getCluster().getPool().get(relays, { kinds: [0], authors: [pubKey] });



function makeId(len: number) {
	const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
	let out = "";
	for (let i = 0; i < len; i++) out += chars[(Math.random() * chars.length) | 0];
	return out;
}
