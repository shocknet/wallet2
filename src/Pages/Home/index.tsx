import { useEffect, useState } from "react";
import moment from 'moment'
//It import svg icons library
import * as Icons from "../../Assets/SvgIconLibrary";

import { SpendFrom, sw_item } from "../../globalTypes";
import { useDispatch, useSelector } from "../../State/store";
import { SwItem } from "../../Components/SwItem";
import { bech32 } from "bech32";
import { Buffer } from "buffer";
import axios from "axios";
import { getNostrClient } from "../../Api";
import { editSpendSources } from "../../State/Slices/spendSourcesSlice";
import { notification } from "antd";
import { NotificationPlacement } from "antd/es/notification/interface";
import * as Types from "../../Api/autogenerated/ts/types"

export const Home = () => {
  const price = useSelector((state) => state.usdToBTC);
  const spendSources = useSelector((state) => state.spendSource);
  const operationGroups = useSelector(({ history }) => history.operations) || {}

  const [error, setError] = useState("")
  const [balance, setBalance] = useState('0.00')
  const [money, setMoney] = useState("0")
  const [items, setItems] = useState<JSX.Element[]>([])

  const [SwItemArray, setSwItemArray] = useState<sw_item[]>([]);
  const dispatch = useDispatch();
  const [api, contextHolder] = notification.useNotification();
  const openNotification = (placement: NotificationPlacement, header: string, text: string) => {
    api.info({
      message: header,
      description:
        text,
      placement
    });
  };

  useEffect(() => {
    console.log(price, operationGroups)
    const entries = Object.entries(operationGroups).filter(([_, v]) => { console.log({ v }); return v.length > 0 })
    if (entries.length === 0) {
      console.log("no operations to display")
      return
    }
    const collapsed: (Types.UserOperation & { nprofile: string })[] = []
    console.log(entries)
    entries.forEach(([nprofile, operations]) => { if (operations) collapsed.push(...operations.map(o => ({ ...o, nprofile }))) })
    setSwItemArray(collapsed.map((o, i) => ({
      priceImg: o.inbound ? Icons.PriceUp : Icons.PriceDown,
      station: o.identifier.length < 20 ? o.identifier : `${o.identifier.substring(0, 9)}...${o.identifier.substring(o.identifier.length - 9, o.identifier.length)}`,
      changes: `${o.inbound ? "" : "-"}${o.amount}`,
      date: moment(o.paidAtUnix*1000).fromNow(),
      price: Math.round(100 * o.amount * price.sellPrice / (100 * 1000 * 1000)) / 100,
      stateIcon: 'lightning',
      underline: i !== collapsed.length - 1
    })) || [])
  }, [])

  useEffect(() => {
    resetSpendFrom();
  }, []);

  useEffect(() => {
    getSumBalances();
  }, [spendSources]);

  const getSumBalances = () => {
    let totalAmount = 0;
    for (let i = 0; i < spendSources.length; i++) {
      const eachAmount = spendSources[i].balance;
      totalAmount += parseInt(eachAmount);
    }
    setBalance(totalAmount.toString());
    setMoney(totalAmount == 0 ? "0" : (totalAmount * price.buyPrice * 0.00000001).toFixed(2))
  }

  const resetSpendFrom = async () => {
    let box: any = spendSources.map((e: SpendFrom) => { return { ...e } });
    await box.map(async (e: SpendFrom, i: number) => {
      const element = e;
      if (element.pasteField.includes("nprofile")) {
        let balanceOfNostr = "0";
        try {
          await (await getNostrClient(element.pasteField)).GetUserInfo().then(res => {
            if (res.status !== 'OK') {
              console.log(res.reason, "reason");
              return
            }
            balanceOfNostr = res.balance.toString()
          })
          box[i].balance = balanceOfNostr;
          dispatch(editSpendSources(box[i]));
        } catch (error) {
          return openNotification("top", "Error", "Couldn't connect to relays");
        }
      } else {
        let { prefix: s, words: dataPart } = bech32.decode(element.pasteField.replace("lightning:", ""), 2000);
        let sourceURL = bech32.fromWords(dataPart);
        const lnurlLink = Buffer.from(sourceURL).toString()
        let amountSats = "0";
        try {
          const amount = await axios.get(lnurlLink);
          amountSats = (amount.data.maxWithdrawable / 1000).toString();

          box[i].balance = parseInt(amountSats).toString();
          dispatch(editSpendSources(box[i]));
        } catch (error: any) {
          box[i].balance = amountSats;
          dispatch(editSpendSources(box[i]));
          console.log(error.response.data.reason);
          return openNotification("top", "Error", (i + 1) + " " + error.response.data.reason);
        }
      }
    });
  }

  const ArrangeData = SwItemArray.map((o, i): JSX.Element => <SwItem
    stateIcon={o.stateIcon}
    station={o.station}
    changes={o.changes}
    price={o.price}
    priceImg={o.priceImg}
    date={o.date}
    key={i}
    underline={o.underline}
  />);

  return (
    <div className="Home">
      <div className="Home_sats">
        <div className="Home_sats_amount">{balance}</div>
        <div className="Home_sats_name">sats</div>
        <div className="Home_sats_changes">~ ${money}</div>
      </div>
      <div className="Home_scroller scroller">
        <div className="Home_content">
          {ArrangeData}
        </div>
      </div>
    </div>
  )
}