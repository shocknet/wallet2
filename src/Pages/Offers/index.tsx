import { useCallback, useEffect, useState } from "react";
import { useSelector, selectConnectedNostrSpends } from '../../State/store/store';
import { PayTo } from "../../globalTypes";
import {
	IonAvatar,
	IonCol,
	IonContent,
	IonFab,
	IonFabButton,
	IonGrid,
	IonHeader,
	IonIcon,
	IonLabel,
	IonList,
	IonNote,
	IonPage,
	IonRow,
	IonToolbar,
	useIonToast
} from "@ionic/react";
import BackToolbar from "@/Layout2/BackToolbar";
import { CustomSelect } from "@/Components/CustomSelect";
import OfferItem from "@/Components/OfferItem";
import { add } from "ionicons/icons";
import type { OfferConfig, OfferInvoice } from "@/Api/pub/autogenerated/ts/types";
import OfferInfoModal from "@/Components/Modals/OfferInfoModal";
import { addUserOffer, deleteUserOffer, getUserOffer, getUserOfferInvoices, getUserOffers, updateUserOffer } from "@/lib/noffer";
import FullSpinner from "@/Components/common/ui/fullSpinner";
import EmptyState from "@/Components/common/ui/emptyState";


const Offers = () => {
	const [present] = useIonToast();
	const enabledNostrPaySources = useSelector(selectConnectedNostrSpends);

	const [selectedSource, setSelectedSource] = useState<PayTo>(enabledNostrPaySources[0]);

	const [modalOpen, setModalOpen] = useState(false);

	const [sourceOffers, setSourceOffers] = useState<OfferConfig[]>([]);
	const [selectedOffer, setSelectedOffer] = useState<OfferConfig | undefined>(undefined);
	const [isLoading, setIsLoading] = useState(true);

	const openForNew = () => { setSelectedOffer(undefined); setModalOpen(true); };
	const openForExisting = (offer: OfferConfig) => { setSelectedOffer(offer); setModalOpen(true); };


	useEffect(() => {
		const getOffers = async () => {
			setIsLoading(true);
			setSourceOffers([]);
			try {
				const offers = await getUserOffers(selectedSource.pasteField, selectedSource.keys);
				setSourceOffers(offers || []);
			} catch (err: any) {
				present({
					message: err?.message || "Failed to fetch offers",
					color: "danger",
					duration: 5000
				});
			}
			setIsLoading(false);
		}

		getOffers();
		// eslint-disable-next-line react-hooks/exhaustive-deps
	}, [selectedSource]);


	const onSave = useCallback(async (offer: OfferConfig, isNew: boolean) => {
		try {
			if (isNew) {
				const newOfferId = await addUserOffer(selectedSource.pasteField, selectedSource.keys, offer);
				const newOffer = await getUserOffer(selectedSource.pasteField, selectedSource.keys, newOfferId);
				setSourceOffers(prevOffers => [...prevOffers, { ...newOffer }]);
			} else {
				await updateUserOffer(selectedSource.pasteField, selectedSource.keys, offer);
				const refetched = await getUserOffer(selectedSource.pasteField, selectedSource.keys, offer.offer_id);

				setSourceOffers(prevOffers => prevOffers.map(o => o.offer_id === offer.offer_id ? refetched : o));
			}
			present({
				message: "Offer saved successfully",
				color: "success",
				duration: 5000
			})
		} catch (err: any) {
			present({
				message: err?.message || "Failed to save offer",
				color: "danger",
				duration: 5000
			})
		}
		setModalOpen(false);
	}, [selectedSource, present])


	const fetchOfferInvoices = useCallback(async (offerId: string): Promise<OfferInvoice[] | null> => {
		try {
			const offerInvoices = await getUserOfferInvoices(selectedSource.pasteField, selectedSource.keys, offerId);
			return offerInvoices;
		} catch (err: any) {
			present({
				message: err?.message || "Failed to fetch offer invoice",
				color: "danger",
				duration: 5000
			});
			return null;
		}
	}, [present, selectedSource]);

	const deleteOffer = useCallback(async (offerId: string) => {
		try {
			await deleteUserOffer(selectedSource.pasteField, selectedSource.keys, offerId);
			setSourceOffers(prevOffers => prevOffers.filter(o => o.offer_id !== offerId));
			present({
				message: "Offer deleted successfully",
				color: "success",
				duration: 5000
			});
		} catch (err: any) {
			present({
				message: err?.message || "Failed to delete user Offer",
				color: "danger",
				duration: 5000
			})
		}
	}, [present, selectedSource])

	return (
		<IonPage className="ion-page-width">
			<IonHeader className="ion-no-border">
				<BackToolbar title="Offers" />
				<IonToolbar className="ion-padding-horizontal ion-padding-bottom">
					<CustomSelect<PayTo>
						items={enabledNostrPaySources}
						selectedItem={selectedSource}
						onSelect={setSelectedSource}
						getIndex={(source) => source.id}
						title="Select Pay Source"
						subTitle="Select a source to see its offers"
						renderItem={(source) => {
							return (
								<>
									<IonAvatar slot="start">
										<img src={`https://robohash.org/${source.pasteField}.png?bgset=bg1`} alt='Avatar' />
									</IonAvatar>
									<IonLabel style={{ width: "100%" }}>
										<h2>{source.label}</h2>
										<IonNote className="ion-text-no-wrap text-low" style={{ display: "block" }}>
											{source.pubSource
												? "Lightning.Pub Source"
												: "LNURL Withdraw Source"}
										</IonNote>
									</IonLabel>
								</>
							)
						}}
						renderSelected={(source) => (
							<>
								<IonAvatar slot="start">
									<img src={`https://robohash.org/${source.pasteField}.png?bgset=bg1`} alt='Avatar' />
								</IonAvatar>
								<IonLabel>
									{source?.label || ''}
								</IonLabel>
							</>
						)}
					>
					</CustomSelect>
				</IonToolbar>
			</IonHeader>
			<IonContent className="ion-padding" fullscreen>
				{
					isLoading ? (
						<FullSpinner />
					) : sourceOffers.length > 0 ? (
						<IonGrid>
							<IonRow className="ion-margin-top">
								<IonCol>
									<IonList lines="none">
										{
											sourceOffers.map((offer, i) => (
												<OfferItem
													key={i}
													offer={({ ...offer, sourceId: selectedSource.id })}
													handleSelectOffer={openForExisting}
													onDelete={deleteOffer}
												/>
											))
										}
									</IonList>
								</IonCol>
							</IonRow>
						</IonGrid>
					) : (
						<div style={{ height: "80%", width: "100%" }}>
							<EmptyState message="The selected source has no offers yet" />
						</div>
					)
				}
				<IonFab slot="fixed" vertical="bottom" horizontal="end">
					<IonFabButton onClick={openForNew}>
						<IonIcon icon={add}></IonIcon>
					</IonFabButton>
				</IonFab>
				<OfferInfoModal
					isOpen={modalOpen}
					onClose={() => setModalOpen(false)}
					onSave={onSave}
					initialOffer={selectedOffer}
					fetchOfferInvoice={fetchOfferInvoices}
				/>
			</IonContent>
		</IonPage>
	);
};

export default Offers;
