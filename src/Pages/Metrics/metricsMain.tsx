import { useCallback, useState, useMemo } from 'react';
import {
	IonButton,
	IonContent,
	IonPage,
	useIonLoading,
	useIonRouter,
	useIonViewWillEnter
} from "@ionic/react";
import { Chart as ChartJS, registerables, Legend } from 'chart.js';
import { Line } from 'react-chartjs-2'
ChartJS.register(...registerables, Legend);
import * as Icons from "../../Assets/SvgIconLibrary";
import { getNostrClient } from '../../Api/nostr';
import * as Types from '../../Api/pub/autogenerated/ts/types';
import styles from "./styles/index.module.scss";
import classNames from 'classnames';
import moment from 'moment';
import { stringToColor } from '../../constants';
import { Period } from '../../Components/Dropdowns/LVDropdown';
import { toast } from "react-toastify";
import Toast from "../../Components/Toast";
import { Client } from '../../Api/nostr';
import { getUnixTimeRange } from './earnings';
import PeriodSelector from '@/Components/Dropdowns/PeriodDropdown/PeriodSelector';
import { nip19 } from 'nostr-tools';
import MetricsHeader from '@/Layout2/Metrics/metricsHeader';
import { useAppSelector } from "@/State/store/hooks";
import { selectAdminNprofileViews } from "@/State/scoped/backups/sources/selectors";
import { selectSelectedMetricsAdminSourceId } from "@/State/runtime/slice";

const trimText = (text: string) => {
	return text.length < 10 ? text : `${text.substring(0, 5)}...${text.substring(text.length - 5, text.length)}`
}

type ResultError = { status: 'ERROR', reason: string }

type ChannelsInfo = {
	offlineChannels: number
	onlineChannels: number
	pendingChannels: number
	closingChannels: number
	bestLocalChan: string
	bestRemoteChan: string
	forwardedEvents: number
	forwardedFees: number
}
type AppsInfo = {
	totalBalance: number
	totalGainAmt: number
	totalGainPct: number
	appsUsers: { appName: string, users: number, invoices: number }[]
}
type RootEvent = { eventType: 'ðŸ”—' | 'ðŸš¨' | 'âš¡ï¸', unix: number, message: string }

const Dashboard = () => {
	const router = useIonRouter();

	const [loading, setLoading] = useState(true)
	const [chainGraphData, setChainGraphData] = useState<Types.GraphPoint[]>([])
	const [chansGraphData, setChansGraphData] = useState<Types.GraphPoint[]>([])
	const [extGraphData, setExtGraphData] = useState<Types.GraphPoint[]>([])
	const [channelsInfo, setChannelsInfo] = useState<ChannelsInfo>()
	const [appsInfo, setAppsInfo] = useState<AppsInfo>()
	const [period, setPeriod] = useState<Period>(Period.WEEK);
	const [error, setError] = useState<string | null>(null)
	const [lndStatus, setLndStatus] = useState("Loading...")
	const [dogStatus, setDogStatus] = useState("Loading...")
	const [rootOps, setRootOps] = useState<RootEvent[]>([])
	const [eventsCollapsed, setEventsCollapsed] = useState(true)
	const [offset, setOffset] = useState(0);

	const [presentLoading, dismissLoading] = useIonLoading();



	const admins = useAppSelector(selectAdminNprofileViews);
	const selectedId = useAppSelector(selectSelectedMetricsAdminSourceId);
	const adminSource = useMemo(
		() => admins.find(a => a.sourceId === selectedId),
		[admins, selectedId]
	)!;

	const fetchInfo = useCallback(async (client: Client) => {
		const info = await client.LndGetInfo({ nodeId: 0 })
		if (info.status !== 'OK') {
			toast.error(<Toast title="Metrics Error" message={`Failed to fetch service status. ${info.reason}`} />)
			return
		}
		setDogStatus(info.watchdog_barking ? "Ops Locked" : "")
		if (!info.synced_to_chain) {
			setLndStatus("Syncing to chain")
			return
		}
		if (!info.synced_to_graph) {
			setLndStatus("Syncing to graph")
			return
		}
		setLndStatus("")
	}, [])

	const fetchMetrics = useCallback(async () => {
		setError(null);


		setLoading(true);

		await dismissLoading();
		await presentLoading("Fetching metrics...");

		try {
			const client = await getNostrClient(
				{ pubkey: adminSource.lpk, relays: adminSource.relays },
				adminSource.keys
			);

			const periodRange = getUnixTimeRange(period, offset);


			const [apps, lnd] = await Promise.all([
				client.GetAppsMetrics({ include_operations: false, ...periodRange }),
				client.GetLndMetrics({ ...periodRange }),
				fetchInfo(client),
			]);

			if (apps.status !== 'OK') {
				setError(apps.reason || "App metrics failed");
				return;
			}
			if (lnd.status !== 'OK') {
				setError(lnd.reason || "Lnd metrics failed");
				return;
			}
			const nodeStats = lnd.nodes[0]
			console.log({ lnd: nodeStats, apps: apps.apps })
			const chain = nodeStats.chain_balance
			const channels = nodeStats.channel_balance
			const external = nodeStats.external_balance
			const showExternal = external.length > 1
			const toMin = []
			const toMax = []
			if (chain.length > 0) {
				toMin.push(chain[0].x)
				toMax.push(chain[chain.length - 1].x)
			}
			if (channels.length > 0) {
				toMin.push(channels[0].x)
				toMax.push(channels[channels.length - 1].x)
			}
			if (external.length > 0) {
				toMin.push(external[0].x)
				toMax.push(external[external.length - 1].x)
			}
			const minBlock = Math.min(...toMin) || 0
			const maxBlock = Math.max(...toMax) || 0
			console.log({ minBlock, maxBlock })

			if (chain.length > 0 && chain[chain.length - 1].x !== maxBlock) {
				chain.push({ x: maxBlock, y: chain[chain.length - 1].y })
			}

			if (channels.length > 0 && channels[channels.length - 1].x !== maxBlock) {
				channels.push({ x: maxBlock, y: channels[channels.length - 1].y })
			}

			if (external.length > 0 && external[external.length - 1].x !== maxBlock) {
				external.push({ x: maxBlock, y: external[external.length - 1].y })
			}
			setChansGraphData(channels)
			setChainGraphData(chain)
			if (showExternal) {
				setExtGraphData(external)
			}
			const bestLocal = { n: "", v: 0 }
			const bestRemote = { n: "", v: 0 }
			const openChannels = nodeStats.open_channels.map(c => {
				if (c.remote_balance > bestRemote.v) {
					bestRemote.v = c.remote_balance; bestRemote.n = c.channel_id
				}
				if (c.local_balance > bestLocal.v) {
					bestLocal.v = c.local_balance; bestLocal.n = c.channel_id
				}
				const e: RootEvent = { eventType: 'ðŸ”—', unix: (Date.now() / 1000 - c.lifetime), message: "Channel Opened" }
				return e
			})
			const closeChans = nodeStats.closed_channels.map(c => {
				const e: RootEvent = { eventType: 'ðŸš¨', unix: c.close_tx_timestamp, message: "Channel Closed" }
				return e
			})
			const ops = nodeStats.root_ops.map(o => {
				const e: RootEvent = { eventType: 'âš¡ï¸', unix: o.created_at_unix, message: `${o.op_type} Root Credit (${o.amount})` }
				return e
			})
			setRootOps([...openChannels, ...closeChans, ...ops].sort((a, b) => b.unix - a.unix))
			setChannelsInfo({
				closingChannels: nodeStats.closing_channels,
				offlineChannels: nodeStats.offline_channels,
				onlineChannels: nodeStats.online_channels,
				pendingChannels: nodeStats.pending_channels,
				bestLocalChan: bestLocal.n,
				bestRemoteChan: bestRemote.n,
				forwardedEvents: nodeStats.forwarding_events,
				forwardedFees: nodeStats.forwarding_fees
			})
			let totalAppsFees = 0
			let appsFeesInFrame = 0
			const appsUsers = apps.apps.map(app => {
				totalAppsFees += app.total_fees
				appsFeesInFrame += app.fees
				return { appName: app.app.name, users: app.users.total, invoices: app.invoices }
			})
			setAppsInfo({
				totalBalance: totalAppsFees,
				totalGainAmt: appsFeesInFrame,
				totalGainPct: totalAppsFees ? (appsFeesInFrame / totalAppsFees) * 100 : 0,
				appsUsers
			})
		} catch (e) {
			console.error(e);
			setError(e instanceof Error ? e.message : "Failed to fetch metrics");
			toast.error(<Toast title="Metrics Error" message={`Failed to fetch metrics. ${e instanceof Error ? e.message : ""}`} />);
		} finally {
			setLoading(false);
			await dismissLoading();
		}
	}, [period, adminSource, offset, fetchInfo, dismissLoading, presentLoading,]);

	useIonViewWillEnter(() => {
		void fetchMetrics();
	}, [selectedId]);

	const nextOffset = () => {
		if (period === Period.ALL_TIME || offset >= 0) {
			return
		}
		setOffset(offset + 1)
	}

	const prevOffset = () => {
		if (period === Period.ALL_TIME) {
			return
		}
		setOffset(offset - 1)
	}

	const gotoChannels = () => {
		router.push("/metrics/channels", "forward");
	}

	return (
		<IonPage className="ion-page-width">
			<MetricsHeader />
			<IonContent className="ion-padding ion-content-no-footer">

				{error && (
					<div style={{ color: "red", padding: 12 }}>
						<div style={{ fontWeight: 700, marginBottom: 8 }}>Something went wrong</div>
						<div style={{ opacity: 0.85, marginBottom: 12 }}>{error}</div>
						<div style={{ display: "flex", gap: 8 }}>
							<IonButton onClick={() => void fetchMetrics()}>Retry</IonButton>
							<IonButton fill="outline" onClick={() => router.push("/metrics/select", "back")}>
								Change Source
							</IonButton>
						</div>
					</div>
				)}


				{
					appsInfo && channelsInfo && !error &&
					(

						<div className={styles["metrics-container"]}>

							<div className={classNames(styles["section"], styles["chart"])}>
								<Line
									data={{
										labels: chainGraphData.map(item => `${item.x}`),
										datasets: [
											{
												label: "Chain " + chainGraphData[chainGraphData.length - 1]?.y || "0",
												data: chainGraphData,
												borderColor: "rgba(199, 64, 199, 0.5)",
												backgroundColor: "rgb(199, 64, 199)",
												yAxisID: "y",
											},
											{
												label: "Channels " + chansGraphData[chansGraphData.length - 1]?.y || "0",
												data: chansGraphData,
												borderColor: "rgba(255, 119, 0, 0.5)",
												backgroundColor: "rgb(255, 119, 0)",
												xAxisID: "x",
											},
										],
									}}
									options={{
										interaction: {
											mode: "index",
											intersect: false,
										},
										layout: {
											padding: 0,
										},
										responsive: true,
										maintainAspectRatio: false,
										aspectRatio: 5 / 2,
										elements: {
											line: {
												borderWidth: 3,
											},
											point: {
												radius: 0,
											},
										},
										plugins: {
											legend: {
												display: true,
												position: "chartArea",
												align: "start",
												maxWidth: 12,
												labels: {
													boxWidth: 10,
													boxHeight: 10,
												},
											},
										},

										scales: {
											x: {
												grid: {
													color: "#383838",
												},
											},
											y: {
												grid: {
													color: "#383838",
												},
												ticks: {
													display: false,
												},
											},
										},
									}}
								/>
							</div>
							<div className={styles["section"]}>
								<div className={styles["between"]}>

									<PeriodSelector period={period} offset={offset} setPeriod={setPeriod} resetOffset={() => setOffset(0)} prevOffset={prevOffset} nextOffset={nextOffset} />
									<IonButton expand="block" fill="clear" color="light" routerLink="/metrics/manage" routerDirection="forward" className={classNames(styles["box"], styles["border"])}>
										Manage
									</IonButton>
								</div>
							</div>
							<div className={styles["section"]}><span className={styles["separator"]}></span></div>
							<div className={styles["section"]}>
								<div style={{ display: 'flex', alignItems: 'center' }}>
									<h3 className={styles["sub-title"]}>Events</h3>
									<span style={{ transform: `rotate(${eventsCollapsed ? 0 : 90}deg)`, transition: "0.3s", }} onClick={() => { setEventsCollapsed(!eventsCollapsed) }}>{Icons.arrow()}</span>
								</div>
								<div className={styles["column-flex"]}>
									{eventsCollapsed &&
										rootOps.slice(0, Math.min(rootOps.length, 2)).map((e, i) => (
											<div key={i} className={styles["event-item"]}><span>{e.message}</span> {e.unix && <span className={styles["date"]}>{moment(e.unix * 1000).fromNow()}</span>}</div>
										))
									}
									{!eventsCollapsed &&
										rootOps.map((e, i) => (
											<div key={i} className={styles["event-item"]}><span>{e.message}</span>  {e.unix && <span className={styles["date"]}>{moment(e.unix * 1000).fromNow()}</span>}</div>
										))
									}
								</div>
							</div>
							<div className={styles["section"]}>
								<h3 className={styles["sub-title"]}>Highlights</h3>
								<div className={styles["cards-container"]}>
									<div className={classNames(styles["card"], styles["net"])} onClick={() => router.push("/metrics/earnings?period=" + period + "&offset=" + offset, "forward")}>
										<div className={styles["top"]}>
											<div className={styles["flx-column"]}>
												<h4 className={styles["card-label"]}>Net</h4>
												<span className={styles["number"]}> +{
													new Intl.NumberFormat('fr-FR').format(appsInfo.totalGainPct)
												}%</span>
											</div>
											<div className={styles["flx-column"]}>
												<span className={classNames(styles["number"], styles["text-right"])}> {
													new Intl.NumberFormat('fr-FR').format(appsInfo.totalBalance)
												}</span>
												<div className={classNames(styles["price"], styles["flex-row"])}>
													{
														appsInfo.totalGainAmt < 0 ? Icons.PriceDown() : Icons.PriceUp()
													}
													<span>{appsInfo.totalGainAmt > 0 ? '+' + new Intl.NumberFormat('fr-FR').format(appsInfo.totalGainAmt) : new Intl.NumberFormat('fr-FR').format(appsInfo.totalGainAmt)}</span>
												</div>
											</div>
										</div>
									</div>
									<div className={classNames(styles["card"], styles["channels"])} onClick={gotoChannels}>
										<div className={styles["top"]}>
											<h4 className={styles["card-label"]}>Channels</h4>
										</div>
										<div className={classNames(styles["bot"], styles["channels-grid"])}>
											<div className={styles["channel"]}><span className={styles["dot"]}></span><span>{channelsInfo.onlineChannels} online</span></div>
											<div className={styles["channel"]}><span className={styles["dot"]}></span><span>{channelsInfo.pendingChannels} pending</span></div>
											<div className={styles["channel"]}><span className={styles["dot"]}></span><span>{channelsInfo.offlineChannels} offline</span></div>
											<div className={styles["channel"]}><span className={styles["dot"]}></span><span>{channelsInfo.closingChannels} closing</span></div>
										</div>
									</div>
									<div className={classNames(styles["card"], styles["top-channels"])}>
										<div className={styles["top"]}>
											<h4 className={styles["card-label"]}>Top Channels</h4>
										</div>
										<div className={classNames(styles["bot"], styles["top-channels"])}>
											<div className={styles["row"]}>
												<span className={styles["label"]}>In:&nbsp;</span>
												<span>{trimText(channelsInfo.bestLocalChan)}</span>
											</div>
											<div className={styles["row"]}>
												<span className={styles["label"]}>Out:&nbsp;</span>
												<span> {trimText(channelsInfo.bestRemoteChan)}</span>
											</div>
										</div>
									</div>
									<div className={classNames(styles["card"], styles["top-channels"], styles["routing"])} onClick={() => router.push("/metrics/routing?period=" + period + "&offset=" + offset)}>
										<div className={styles["top"]}>
											<h4 className={styles["card-label"]}>Routing</h4>
										</div>
										<div className={classNames(styles["bot"], styles["top-channels"])}>
											<div className={styles["row"]}>
												{channelsInfo.forwardedEvents} forwards
											</div>
											<div className={styles["row"]}>
												{channelsInfo.forwardedFees} sats
											</div>
										</div>
									</div>
									{
										appsInfo.appsUsers.map(app => (
											<div key={app.appName}
												className={classNames(styles["card"], styles["top-channels"])}
												style={{ borderColor: stringToColor(app.appName) }}
											>
												<div className={styles["top"]}>
													<h4 className={styles["card-label"]}>{app.appName}</h4>
												</div>
												<div className={classNames(styles["bot"], styles["top-channels"])}>
													<div className={styles["row"]}>
														{app.users} users
													</div>
													<div className={styles["row"]}>
														{app.invoices} invoices
													</div>
												</div>
											</div>
										))
									}
								</div>
							</div>
							<br />
							<div className={styles["section"]}>
								<div className="Status">
									<div className="Status_title">Lightning Status:</div>
									<div className="Status_value">
										{lndStatus && Icons.YellowState()}
										{!lndStatus && Icons.GreenState()}
										<span>{lndStatus || "Synced"}</span>
									</div>
								</div>
							</div>
							<div className={styles["section"]}>
								<div className="Status">
									<div className="Status_title">Watchdog Status:</div>
									<div className="Status_value">
										{dogStatus && Icons.GreenState()}
										{!dogStatus && Icons.GreenState()}
										<span>{dogStatus || "No Alarms"}</span>
									</div>
								</div>
							</div>
							<div className={styles["section"]}>
								<IonButton expand="block" fill="clear" color="light" routerLink="/metrics/swaps" routerDirection="forward" className={classNames(styles["box"], styles["border"])}>
									Swaps
								</IonButton>
							</div>
							<div className={styles["section"]}>
								<div className='metric-footer'>
									<i>
										Connected to <br />
										{adminSource
											? nip19.nprofileEncode({ pubkey: adminSource.lpk, relays: adminSource.relays })
											: "(no source)"}
									</i>
								</div>
							</div>
						</div>
					)
				}
			</IonContent>
		</IonPage>
	);
}

export default Dashboard;
