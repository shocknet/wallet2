import { useEffect, useMemo, useState } from "react"
import { Period } from "../../Components/Dropdowns/LVDropdown"
import { getNostrClient } from "@/Api/nostr"
import { toast } from "react-toastify";
import * as Types from '../../Api/pub/autogenerated/ts/types';
import {
    IonButton,
    IonCard,
    IonCardContent,
    IonCardHeader,
    IonContent,
    IonLabel,
    IonItem,
    IonList,
    IonListHeader,
    IonPage,
    IonHeader,
    useIonLoading,
    useIonRouter,
    IonSkeletonText,
} from "@ionic/react";
import PeriodSelector from "@/Components/Dropdowns/PeriodDropdown/PeriodSelector";
import MetricsSubPageToolbar from "@/Layout2/Metrics/MetricsSubPageToolbar";


import { useAppSelector } from "@/State/store/hooks";
import { selectAdminNprofileViews } from "@/State/scoped/backups/sources/selectors";
import { selectSelectedMetricsAdminSourceId } from "@/State/runtime/slice";
import { flashOutline, linkOutline, personOutline } from "ionicons/icons";

export default function Routing() {
    const router = useIonRouter();

    const [period, setPeriod] = useState<Period>(Period.WEEK)
    const [offset, setOffset] = useState<number>(0)


    const admins = useAppSelector(selectAdminNprofileViews);
    const selectedId = useAppSelector(selectSelectedMetricsAdminSourceId);
    const adminSource = useMemo(
        () => admins.find(a => a.sourceId === selectedId),
        [admins, selectedId]
    )!;

    const [fwMetrics, setFwMetrics] = useState<Types.LndForwardingMetrics>()
    const [channels, setChannels] = useState<Types.OpenChannel[]>([])
    const [totalOut, setTotalOut] = useState<number>(0)
    const [showingOps, setShowingOps] = useState("")
    const [loading, setLoading] = useState(true)
    const [error, setError] = useState<string | null>(null);

    const [presentLoading, dismissLoading] = useIonLoading();

    useEffect(() => {
        const params = new URLSearchParams(window.location.search)
        const period = params.get("period")
        const offset = params.get("offset")
        if (period) {
            setPeriod(period as Period)
        }
        if (offset) {
            setOffset(parseInt(offset))
        }
    }, [])
    useEffect(() => {
        fetchMetrics()
    }, [period, offset, adminSource])
    const nextOffset = () => {
        if (period === Period.ALL_TIME || offset >= 0) {
            return
        }
        setOffset(offset + 1)
    }

    const prevOffset = () => {
        if (period === Period.ALL_TIME) {
            return
        }
        setOffset(offset - 1)
    }

    const fetchMetrics = async () => {
        setError(null);
        setLoading(true);

        await dismissLoading();
        await presentLoading("Fetching routing...");

        try {
            const client = await getNostrClient(
                { pubkey: adminSource.lpk, relays: adminSource.relays },
                adminSource.keys
            );

            const periodRange = getUnixTimeRange(period, offset);

            const [lndFwMetrics, channelsRes] = await Promise.all([
                client.GetLndForwardingMetrics({ ...periodRange }),
                client.ListChannels()
            ]);


            if (channelsRes.status !== 'OK') {
                setError(channelsRes.reason || "Failed to list channels");
                toast.error(channelsRes.reason);
                return;
            }
            setChannels(channelsRes.open_channels);


            if (lndFwMetrics.status !== 'OK') {
                setError(lndFwMetrics.reason || "Failed to fetch forwarding metrics");
                toast.error(lndFwMetrics.reason);
                return;
            }

            setFwMetrics(lndFwMetrics);

            let totOut = 0
            lndFwMetrics.events.forEach(fw => {
                totOut += fw.amt_out
            })
            setTotalOut(totOut);

        } catch (e) {
            console.error(e);
            const msg = e instanceof Error ? e.message : "Failed to fetch routing";
            setError(msg);
            toast.error(msg);
        } finally {
            setLoading(false);
            await dismissLoading();
        }
    };



    return <IonPage className="ion-page-width">
        <IonHeader className="ion-no-border">
            <MetricsSubPageToolbar title="Routing" />
        </IonHeader>

        <IonContent className="ion-padding ion-content-no-footer">
            {error && (
                <div style={{ color: "red", padding: 12 }}>
                    <div style={{ fontWeight: 700, marginBottom: 8 }}>Something went wrong</div>
                    <div style={{ opacity: 0.85, marginBottom: 12 }}>{error}</div>
                    <div style={{ display: "flex", gap: 8 }}>
                        <IonButton onClick={() => void fetchMetrics()}>Retry</IonButton>
                        <IonButton fill="outline" onClick={() => router.push("/metrics/select", "back")}>
                            Change Source
                        </IonButton>
                    </div>
                </div>
            )}

            {!error && (
                <>
                    <PeriodSelector
                        period={period}
                        offset={offset}
                        setPeriod={setPeriod}
                        resetOffset={() => setOffset(0)}
                        prevOffset={prevOffset}
                        nextOffset={nextOffset}
                    />

                    <IonCard style={{ width: '100%', marginTop: 10 }} color="secondary">
                        <IonCardHeader>Lnd Forwarding</IonCardHeader>

                        {loading && <IonCardContent>
                            <IonSkeletonText animated style={{ width: '70%' }} />
                            <IonSkeletonText animated style={{ width: '30%' }} />
                        </IonCardContent>}

                        {!loading && (!fwMetrics || fwMetrics.events.length === 0) && (
                            <IonCardContent>
                                <div>No operations</div>
                            </IonCardContent>
                        )}

                        {!loading && fwMetrics && fwMetrics.events.length > 0 && (
                            <IonCardContent>
                                <div>Moved {totalOut} sats in {fwMetrics.events.length} htlcs</div>
                                <div>Earned {fwMetrics.total_fees} sats</div>

                                {showingOps !== '__lnd' && (
                                    <IonButton onClick={() => setShowingOps("__lnd")}>Show Htlcs</IonButton>
                                )}
                                {showingOps === '__lnd' && (
                                    <IonButton onClick={() => setShowingOps("")}>Hide Htlcs</IonButton>
                                )}

                                {showingOps === '__lnd' && (
                                    <IonList>
                                        <IonListHeader>
                                            <IonLabel>From</IonLabel>
                                            <IonLabel>Sats In</IonLabel>
                                            <IonLabel>Sats Out</IonLabel>
                                            <IonLabel>Fees</IonLabel>
                                            <IonLabel>To</IonLabel>
                                        </IonListHeader>

                                        {fwMetrics.events.map((fw, i) => (
                                            <IonItem key={i}>
                                                <IonLabel>{channels.find(c => c.channel_id === fw.chan_id_in)?.label || fw.chan_id_in}</IonLabel>
                                                <IonLabel>{fw.amt_in}</IonLabel>
                                                <IonLabel>{fw.amt_out}</IonLabel>
                                                <IonLabel>{fw.fee}</IonLabel>
                                                <IonLabel>{channels.find(c => c.channel_id === fw.chan_id_out)?.label || fw.chan_id_out}</IonLabel>
                                            </IonItem>
                                        ))}
                                    </IonList>
                                )}
                            </IonCardContent>
                        )}
                    </IonCard>
                </>
            )}
        </IonContent>
    </IonPage>
}

export const getUnixTimeRange = (period: Period, offset: number) => {
    const now = new Date();
    let from_unix: number, to_unix: number;

    switch (period) {
        case Period.WEEK: {
            /*       const thisWeek = new Date(now.setDate(now.getDate() - now.getDay()))
                                    thisWeek.setHours(0, 0, 0, 0)
                                    console.log({ thisWeek: thisWeek.toISOString() })
                                    const thisWeekMs = thisWeek.getTime() */

            const firstDayOfWeek = new Date(new Date().setDate(now.getDate() - now.getDay() + (offset * 7))).setHours(0, 0, 0, 0);
            const lastDayOfWeek = new Date(new Date().setDate(now.getDate() - now.getDay() + 6 + (offset * 7))).setHours(23, 59, 59, 999);
            from_unix = Math.floor(firstDayOfWeek / 1000);
            to_unix = Math.floor(lastDayOfWeek / 1000);
            break;
        }

        case Period.MONTH: {
            const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth() + offset, 1).getTime();
            const lastDayOfMonth = new Date(now.getFullYear(), now.getMonth() + 1 + offset, 0).setHours(23, 59, 59, 999);
            from_unix = Math.floor(firstDayOfMonth / 1000);
            to_unix = Math.floor(lastDayOfMonth / 1000);
            break;
        }

        case Period.YEAR: {
            const firstDayOfYear = new Date(now.getFullYear() + offset, 0, 1).getTime();
            const lastDayOfYear = new Date(now.getFullYear() + offset, 11, 31).setHours(23, 59, 59, 999);
            from_unix = Math.floor(firstDayOfYear / 1000);
            to_unix = Math.floor(lastDayOfYear / 1000);
            break;
        }
        case Period.ALL_TIME:
            return undefined
    }
    console.log({ from_unix: new Date(from_unix * 1000).toISOString(), to_unix: new Date(to_unix * 1000).toISOString() })
    return { from_unix, to_unix };
}

const iconType = (t: Types.UserOperationType) => {
    switch (t) {
        case Types.UserOperationType.INCOMING_INVOICE:
        case Types.UserOperationType.OUTGOING_INVOICE:
            return flashOutline
        case Types.UserOperationType.INCOMING_USER_TO_USER:
        case Types.UserOperationType.OUTGOING_USER_TO_USER:
            return personOutline
        case Types.UserOperationType.INCOMING_TX:
        case Types.UserOperationType.OUTGOING_TX:
            return linkOutline
    }
}

const iconColor = (t: Types.UserOperationType) => {
    switch (t) {
        case Types.UserOperationType.INCOMING_INVOICE:
        case Types.UserOperationType.INCOMING_USER_TO_USER:
        case Types.UserOperationType.INCOMING_TX:
            return 'green'
        case Types.UserOperationType.OUTGOING_INVOICE:
        case Types.UserOperationType.OUTGOING_USER_TO_USER:
        case Types.UserOperationType.OUTGOING_TX:
            return 'red'
        default:
            return 'white'
    }
}
