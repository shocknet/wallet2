import { useCallback, useEffect, useState } from 'react';
import { useIonRouter } from "@ionic/react";
import { Chart as ChartJS, registerables, Legend } from 'chart.js';
import { Line } from 'react-chartjs-2'
ChartJS.register(...registerables, Legend);
import * as Icons from "../../Assets/SvgIconLibrary";
import { useDispatch } from '../../State/store/store';
import { getNostrClient } from '../../Api/nostr';
import * as Types from '../../Api/pub/autogenerated/ts/types';
import styles from "./styles/index.module.scss";
import classNames from 'classnames';
import moment from 'moment';
import { toggleLoading } from '../../State/Slices/loadingOverlay';
import { stringToColor } from '../../constants';
import { Period } from '../../Components/Dropdowns/LVDropdown';
import { toast } from "react-toastify";
import Toast from "../../Components/Toast";
import { Client } from '../../Api/nostr';
import Manage from '../Manage';
import Channels from '../Channels';
import { AdminGuard } from '../../Components/AdminGuard';
import { getUnixTimeRange } from './earnings';
import PeriodSelector from '@/Components/Dropdowns/PeriodDropdown/PeriodSelector';
import type { AdminSource } from '@/Components/AdminGuard/helpers';

const trimText = (text: string) => {
	return text.length < 10 ? text : `${text.substring(0, 5)}...${text.substring(text.length - 5, text.length)}`
}

const getTimeAgo = (secondsAgo: number) => {
	return moment().subtract(secondsAgo, 'seconds').fromNow();
}

type ResultError = { status: 'ERROR', reason: string }

type Creds = { url: string, metricsToken: string }
type ChannelsInfo = {
	offlineChannels: number
	onlineChannels: number
	pendingChannels: number
	closingChannels: number
	bestLocalChan: string
	bestRemoteChan: string
	forwardedEvents: number
	forwardedFees: number
}
type AppsInfo = {
	totalBalance: number
	totalGainAmt: number
	totalGainPct: number
	appsUsers: { appName: string, users: number, invoices: number }[]
}
type RootEvent = { eventType: '🔗' | '🚨' | '⚡️', unix: number, message: string }
const saveCreds = (creds: Creds) => {
	localStorage.setItem("metrics-creds", JSON.stringify(creds))
}
const getCreds = () => {
	const v = localStorage.getItem("metrics-creds")
	if (!v) {
		return null
	}
	return JSON.parse(v) as Creds
}








const Metrics = () => {
	//const [url, setUrl] = useState("")
	//const [metricsToken, setMetricsToken] = useState("")
	const router = useIonRouter();

	const [loading, setLoading] = useState(true)
	const [chainGraphData, setChainGraphData] = useState<Types.GraphPoint[]>([])
	const [chansGraphData, setChansGraphData] = useState<Types.GraphPoint[]>([])
	const [extGraphData, setExtGraphData] = useState<Types.GraphPoint[]>([])
	//const [lndGraphsData, setLndGraphsData] = useState<LndGraphs>()
	const [channelsInfo, setChannelsInfo] = useState<ChannelsInfo>()
	const [appsInfo, setAppsInfo] = useState<AppsInfo>()
	const [period, setPeriod] = useState<Period>(Period.WEEK);
	/* const [firstRender, setFirstRender] = useState(true); */
	const [error, setError] = useState("")
	const [lndStatus, setLndStatus] = useState("Loading...")
	const [dogStatus, setDogStatus] = useState("Loading...")
	const [rootOps, setRootOps] = useState<RootEvent[]>([])
	const [eventsCollapsed, setEventsCollapsed] = useState(true)
	const [showManage, setShowManage] = useState(false)
	const [showChannels, setShowChannels] = useState(false)
	const [adminSource, setAdminSource] = useState<AdminSource | null>(null)
	const [offset, setOffset] = useState(0)

	/* const spendSources = useSelector(state => state.spendSource) */
	const dispatch = useDispatch();

	//const otherOptions = periodOptionsArray.filter((o) => o !== period);
	/* const selectedSource = useMemo(() => {
		return spendSources.order.find(p => !!spendSources.sources[p].adminToken)
	}, [spendSources]) */

	useEffect(() => {
		fetchMetrics();
	}, [adminSource, period, offset]);

	const fetchInfo = useCallback(async (client: Client) => {
		const info = await client.LndGetInfo({ nodeId: 0 })
		if (info.status !== 'OK') {
			toast.error(<Toast title="Metrics Error" message={`Failed to fetch service status. ${info.reason}`} />)
			return
		}
		setDogStatus(info.watchdog_barking ? "Ops Locked" : "")
		if (!info.synced_to_chain) {
			setLndStatus("Syncing to chain")
			return
		}
		if (!info.synced_to_graph) {
			setLndStatus("Syncing to graph")
			return
		}
		setLndStatus("")
	}, [])

	const fetchMetrics = useCallback(async () => {
		console.log("fetching metrics")
		if (!adminSource) {
			//setError("no available admin source found")
			//setLoading(false)
			return
		}
		/*     const source = spendSources.sources[selectedSource]
				if (!source || !source.adminToken) {
					setError("no available admin source found")
					setLoading(false)
					return
				} */
		console.log("fetching metrics2")
		dispatch(toggleLoading({ loadingMessage: "Fetching metrics..." }));
		const client = await getNostrClient(adminSource.nprofile, adminSource.keys)
		const periodRange = getUnixTimeRange(period, offset);
		let apps: ResultError | ({ status: 'OK' } & Types.AppsMetrics), lnd: ResultError | ({ status: 'OK' } & Types.LndMetrics)
		try {
			[apps, lnd] = await Promise.all([client.GetAppsMetrics({ include_operations: false, ...periodRange }), client.GetLndMetrics({ ...periodRange }), fetchInfo(client)])
		} catch (error) {
			console.error(error);
			setLoading(false);
			dispatch(toggleLoading({ loadingMessage: "" }));
			toast.error(<Toast title="Metrics Error" message={`Failed to fetch metrics. ${error instanceof Error ? error.message : ""}`} />);
			return;
		}
		if (apps.status !== 'OK') {
			setLoading(false);
			dispatch(toggleLoading({ loadingMessage: "" }));
			toast.error(<Toast title="Metrics Error" message={apps.reason} />);
			return;
		}
		if (lnd.status !== 'OK') {
			setLoading(false);
			dispatch(toggleLoading({ loadingMessage: "" }));
			toast.error(<Toast title="Metrics Error" message={lnd.reason} />);
			return;
		}
		const nodeStats = lnd.nodes[0]
		console.log({ lnd: nodeStats, apps: apps.apps })
		const chain = nodeStats.chain_balance
		const channels = nodeStats.channel_balance
		const external = nodeStats.external_balance
		const showExternal = external.length > 1
		const toMin = []
		const toMax = []
		if (chain.length > 0) {
			toMin.push(chain[0].x)
			toMax.push(chain[chain.length - 1].x)
		}
		if (channels.length > 0) {
			toMin.push(channels[0].x)
			toMax.push(channels[channels.length - 1].x)
		}
		if (external.length > 0) {
			toMin.push(external[0].x)
			toMax.push(external[external.length - 1].x)
		}
		const minBlock = Math.min(...toMin) || 0
		const maxBlock = Math.max(...toMax) || 0
		console.log({ minBlock, maxBlock })

		if (chain.length > 0 && chain[chain.length - 1].x !== maxBlock) {
			chain.push({ x: maxBlock, y: chain[chain.length - 1].y })
		}

		if (channels.length > 0 && channels[channels.length - 1].x !== maxBlock) {
			channels.push({ x: maxBlock, y: channels[channels.length - 1].y })
		}

		if (external.length > 0 && external[external.length - 1].x !== maxBlock) {
			external.push({ x: maxBlock, y: external[external.length - 1].y })
		}
		setChansGraphData(channels)
		setChainGraphData(chain)
		if (showExternal) {
			setExtGraphData(external)
		}
		const bestLocal = { n: "", v: 0 }
		const bestRemote = { n: "", v: 0 }
		const openChannels = nodeStats.open_channels.map(c => {
			if (c.remote_balance > bestRemote.v) {
				bestRemote.v = c.remote_balance; bestRemote.n = c.channel_id
			}
			if (c.local_balance > bestLocal.v) {
				bestLocal.v = c.remote_balance; bestLocal.n = c.channel_id
			}
			const e: RootEvent = { eventType: '🔗', unix: (Date.now() / 1000 - c.lifetime), message: "Channel Opened" }
			return e
		})
		const closeChans = nodeStats.closed_channels.map(c => {
			const e: RootEvent = { eventType: '🚨', unix: c.close_tx_timestamp, message: "Channel Closed" }
			return e
		})
		const ops = nodeStats.root_ops.map(o => {
			const e: RootEvent = { eventType: '⚡️', unix: o.created_at_unix, message: `${o.op_type} Root Credit (${o.amount})` }
			return e
		})
		setRootOps([...openChannels, ...closeChans, ...ops].sort((a, b) => b.unix - a.unix))
		setChannelsInfo({
			closingChannels: nodeStats.closing_channels,
			offlineChannels: nodeStats.offline_channels,
			onlineChannels: nodeStats.online_channels,
			pendingChannels: nodeStats.pending_channels,
			bestLocalChan: bestLocal.n,
			bestRemoteChan: bestRemote.n,
			forwardedEvents: nodeStats.forwarding_events,
			forwardedFees: nodeStats.forwarding_fees
		})
		let totalAppsFees = 0
		let appsFeesInFrame = 0
		const appsUsers = apps.apps.map(app => {
			totalAppsFees += app.total_fees
			appsFeesInFrame += app.fees
			return { appName: app.app.name, users: app.users.total, invoices: app.invoices }
		})
		setAppsInfo({
			totalBalance: totalAppsFees,
			totalGainAmt: appsFeesInFrame,
			totalGainPct: (appsFeesInFrame / totalAppsFees) * 100,
			appsUsers
		})
		setLoading(false)
		dispatch(toggleLoading({ loadingMessage: "" }));
	}, [dispatch, period, adminSource, offset]);

	const nextOffset = () => {
		if (period === Period.ALL_TIME || offset >= 0) {
			return
		}
		setOffset(offset + 1)
	}

	const prevOffset = () => {
		if (period === Period.ALL_TIME) {
			return
		}
		setOffset(offset - 1)
	}
	if (!adminSource) {
		return <AdminGuard updateSource={s => { console.log({ adminSource }); setAdminSource(s) }} />
	}

	if (loading) {
		return <div>loading...</div>
	}

	if (!channelsInfo || !appsInfo || error) {
		return <div style={{ color: 'red' }}>
			something went wrong {error}

		</div>
	}

	if (showManage) {
		return <Manage done={() => setShowManage(false)} />
	}
	if (showChannels) {
		return <Channels done={() => setShowChannels(false)} />
	}
	const datasets = [
		{
			data: chainGraphData,
			label: "Chain " + chainGraphData[chainGraphData.length - 1]?.y || "0",
			showLine: true,
			fill: false,
			borderWidth: 1
		}, {
			data: chansGraphData,
			label: "Channels " + chansGraphData[chansGraphData.length - 1]?.y || "0",
			showLine: true,
			fill: false,
			borderWidth: 1
		}
	]
	if (extGraphData.length > 0) {
		datasets.push({
			data: extGraphData,
			label: "LSP Credit " + extGraphData[extGraphData.length - 1]?.y || "0",
			showLine: true,
			fill: false,
			borderWidth: 1
		})
	}
	return <div>
		<div className={styles["metrics-container"]}>

			<div className={classNames(styles["section"], styles["chart"])}>
				<Line
					data={{
						labels: chainGraphData.map(item => `${item.x}`),
						datasets: [
							{
								label: "Chain " + chainGraphData[chainGraphData.length - 1]?.y || "0",
								data: chainGraphData,
								borderColor: "rgba(199, 64, 199, 0.5)",
								backgroundColor: "rgb(199, 64, 199)",
								yAxisID: "y",
							},
							{
								label: "Channels " + chansGraphData[chansGraphData.length - 1]?.y || "0",
								data: chansGraphData,
								borderColor: "rgba(255, 119, 0, 0.5)",
								backgroundColor: "rgb(255, 119, 0)",
								xAxisID: "x",
							},
						],
					}}
					options={{
						interaction: {
							mode: "index",
							intersect: false,
						},
						layout: {
							padding: 0,
						},
						responsive: true,
						maintainAspectRatio: false,
						aspectRatio: 5 / 2,
						elements: {
							line: {
								borderWidth: 3,
							},
							point: {
								radius: 0,
							},
						},
						plugins: {
							legend: {
								display: true,
								position: "chartArea",
								align: "start",
								maxWidth: 12,
								labels: {
									boxWidth: 10,
									boxHeight: 10,
								},
							},
						},

						scales: {
							x: {
								grid: {
									color: "#383838",
								},
							},
							y: {
								grid: {
									color: "#383838",
								},
								ticks: {
									display: false,
								},
							},
						},
					}}
				/>
			</div>
			<div className={styles["section"]}>
				<div className={styles["between"]}>

					<PeriodSelector period={period} offset={offset} setPeriod={setPeriod} resetOffset={() => setOffset(0)} prevOffset={prevOffset} nextOffset={nextOffset} />
					<div onClick={() => setShowManage(true)} style={{ cursor: "pointer" }} className={classNames(styles["box"], styles["border"])}>
						Manage
					</div>
				</div>
			</div>
			<div className={styles["section"]}><span className={styles["separator"]}></span></div>
			<div className={styles["section"]}>
				<div style={{ display: 'flex', alignItems: 'center' }}>
					<h3 className={styles["sub-title"]}>Events</h3>
					<span style={{ transform: `rotate(${eventsCollapsed ? 0 : 90}deg)`, transition: "0.3s", }} onClick={() => { setEventsCollapsed(!eventsCollapsed) }}>{Icons.arrow()}</span>
				</div>
				<div className={styles["column-flex"]}>
					{eventsCollapsed &&
						rootOps.slice(0, Math.min(rootOps.length, 2)).map((e, i) => (
							<div key={i} className={styles["event-item"]}><span>{e.message}</span> {e.unix && <span className={styles["date"]}>{moment(e.unix * 1000).fromNow()}</span>}</div>
						))
					}
					{!eventsCollapsed &&
						rootOps.map((e, i) => (
							<div key={i} className={styles["event-item"]}><span>{e.message}</span>  {e.unix && <span className={styles["date"]}>{moment(e.unix * 1000).fromNow()}</span>}</div>
						))
					}
				</div>
			</div>
			<div className={styles["section"]}>
				<h3 className={styles["sub-title"]}>Highlights</h3>
				<div className={styles["cards-container"]}>
					<div className={classNames(styles["card"], styles["net"])} onClick={() => router.push("/metrics/earnings?period=" + period + "&offset=" + offset)}>
						<div className={styles["top"]}>
							<div className={styles["flx-column"]}>
								<h4 className={styles["card-label"]}>Net</h4>
								<span className={styles["number"]}> +{
									new Intl.NumberFormat('fr-FR').format(appsInfo.totalGainPct)
								}%</span>
							</div>
							<div className={styles["flx-column"]}>
								<span className={classNames(styles["number"], styles["text-right"])}> {
									new Intl.NumberFormat('fr-FR').format(appsInfo.totalBalance)
								}</span>
								<div className={classNames(styles["price"], styles["flex-row"])}>
									{
										appsInfo.totalGainAmt < 0 ? Icons.PriceDown() : Icons.PriceUp()
									}
									<span>{appsInfo.totalGainAmt > 0 ? '+' + new Intl.NumberFormat('fr-FR').format(appsInfo.totalGainAmt) : new Intl.NumberFormat('fr-FR').format(appsInfo.totalGainAmt)}</span>
								</div>
							</div>
						</div>
					</div>
					<div className={classNames(styles["card"], styles["channels"])} onClick={() => setShowChannels(true)}>
						<div className={styles["top"]}>
							<h4 className={styles["card-label"]}>Channels</h4>
						</div>
						<div className={classNames(styles["bot"], styles["channels-grid"])}>
							<div className={styles["channel"]}><span className={styles["dot"]}></span><span>{channelsInfo.onlineChannels} online</span></div>
							<div className={styles["channel"]}><span className={styles["dot"]}></span><span>{channelsInfo.pendingChannels} pending</span></div>
							<div className={styles["channel"]}><span className={styles["dot"]}></span><span>{channelsInfo.offlineChannels} offline</span></div>
							<div className={styles["channel"]}><span className={styles["dot"]}></span><span>{channelsInfo.closingChannels} closing</span></div>
						</div>
					</div>
					<div className={classNames(styles["card"], styles["top-channels"])}>
						<div className={styles["top"]}>
							<h4 className={styles["card-label"]}>Top Channels</h4>
						</div>
						<div className={classNames(styles["bot"], styles["top-channels"])}>
							<div className={styles["row"]}>
								<span className={styles["label"]}>In:&nbsp;</span>
								<span>{trimText(channelsInfo.bestLocalChan)}</span>
							</div>
							<div className={styles["row"]}>
								<span className={styles["label"]}>Out:&nbsp;</span>
								<span> {trimText(channelsInfo.bestRemoteChan)}</span>
							</div>
						</div>
					</div>
					<div className={classNames(styles["card"], styles["top-channels"], styles["routing"])} onClick={() => router.push("/metrics/routing?period=" + period + "&offset=" + offset)}>
						<div className={styles["top"]}>
							<h4 className={styles["card-label"]}>Routing</h4>
						</div>
						<div className={classNames(styles["bot"], styles["top-channels"])}>
							<div className={styles["row"]}>
								{channelsInfo.forwardedEvents} forwards
							</div>
							<div className={styles["row"]}>
								{channelsInfo.forwardedFees} sats
							</div>
						</div>
					</div>
					{
						appsInfo.appsUsers.map(app => (
							<div key={app.appName}
								className={classNames(styles["card"], styles["top-channels"])}
								style={{ borderColor: stringToColor(app.appName) }}
							>
								<div className={styles["top"]}>
									<h4 className={styles["card-label"]}>{app.appName}</h4>
								</div>
								<div className={classNames(styles["bot"], styles["top-channels"])}>
									<div className={styles["row"]}>
										{app.users} users
									</div>
									<div className={styles["row"]}>
										{app.invoices} invoices
									</div>
								</div>
							</div>
						))
					}
				</div>
			</div>
			<br />
			<div className={styles["section"]}>
				<div className="Status">
					<div className="Status_title">Lightning Status:</div>
					<div className="Status_value">
						{lndStatus && Icons.YellowState()}
						{!lndStatus && Icons.GreenState()}
						<span>{lndStatus || "Synced"}</span>
					</div>
				</div>
			</div>
			<div className={styles["section"]}>
				<div className="Status">
					<div className="Status_title">Watchdog Status:</div>
					<div className="Status_value">
						{dogStatus && Icons.GreenState()}
						{!dogStatus && Icons.GreenState()}
						<span>{dogStatus || "No Alarms"}</span>
					</div>
				</div>
			</div>
			<div className={styles["section"]}>
				<div className='metric-footer'>
					<i>Connected to <br />{adminSource.nprofile}</i>
				</div>
			</div>
		</div>
	</div>
}

export default Metrics;

