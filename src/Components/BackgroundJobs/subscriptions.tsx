import { useEffect } from "react"
import { useDispatch, useSelector } from "../../State/store"
import { Subscription, SubscriptionPayment, addSubPayment } from "../../State/Slices/subscriptionsSlice"
import { InputClassification, openNotification, usdToBTCSpotLink } from "../../constants"
import { createLnurlInvoice, handlePayInvoice } from "../../Api/helpers"
import axios from "axios"
import { parseNprofile } from "../../Api/nostr"
import { setLatestOperation } from "../../State/Slices/HistorySlice"
import { UserOperationType } from "../../Api/autogenerated/ts/types"
const SubsCheckIntervalSeconds = 60 * 60
export const SubscriptionsBackground = () => {
    const activeSubs = useSelector(({ subscriptions }) => subscriptions.activeSubs)
    const payments = useSelector(({ subscriptions }) => subscriptions.payments)
    const BTCUSDUrl = useSelector(({ prefs }) => prefs.BTCUSDUrl)
    const spendSources = useSelector((state) => state.spendSource.filter(s => !s.disabled));
    const dispatch = useDispatch();

    useEffect(() => {
        const interval = setInterval(() => {
            checkSubsState()
        }, SubsCheckIntervalSeconds * 1000)
        checkSubsState()
        return () => {
            clearInterval(interval)
        }
    }, [])

    const checkSubsState = () => {
        console.log("checking subscriptions state...")
        const nowUnix = Math.floor(Date.now() / 1000)
        activeSubs.forEach(sub => {
            let maxEnd = 0
            let maxIndex = -1
            const subPayments = (payments[sub.subId] || [])
            subPayments.forEach((payment, index) => {
                if (payment.periodEndUnix > maxEnd) {
                    maxEnd = payment.periodEndUnix
                    maxIndex = index
                }
            })
            if (maxEnd - sub.periodSeconds > nowUnix) {
                console.log("sub", sub.subId, "is up to date")
                return
            }
            console.log("subscription", sub.subId, "needs renew")
            sendSubPayment(sub, maxIndex !== -1 ? subPayments[maxIndex] : null)
        })
    }

    const sendSubPayment = async (sub: Subscription, latestPayment: SubscriptionPayment | null) => {
        if (sub.destionation.type !== InputClassification.LN_ADDRESS) {
            console.log("subscription payment destionation not supported", sub.destionation.type)
            return
        }
        try {
            let sats = sub.price.amt
            const spendSource = spendSources[0]
            if (sub.price.type = 'cents') {
                const { data } = await axios.get(BTCUSDUrl || usdToBTCSpotLink);
                const btcUsd = data.amount as number
                const satsUsd = btcUsd / 100_000_000
                sats = (sub.price.amt / 100) / satsUsd
            }
            const invoice = await createLnurlInvoice(sats, sub.destionation);
            const payRes = await handlePayInvoice(invoice, spendSource.pasteField);
            const now = Date.now() / 1000
            dispatch(setLatestOperation({
                pub: parseNprofile(spendSource.pasteField).pubkey, operation: {
                    amount: sats, identifier: invoice, inbound: false, operationId: payRes.operation_id,
                    paidAtUnix: now, type: UserOperationType.OUTGOING_INVOICE, network_fee: payRes.network_fee, service_fee: payRes.service_fee,
                    confirmed: true,
                }
            }))
            const periodNumber = latestPayment ? latestPayment.periodNumber + 1 : 1
            const periodStartUnix = latestPayment ? latestPayment.periodEndUnix : sub.subbedAtUnix
            dispatch(addSubPayment({
                payment: {
                    operationId: payRes.operation_id,
                    paidSats: sats,
                    subId: sub.subId,
                    periodNumber,
                    periodStartUnix,
                    periodEndUnix: periodStartUnix + sub.periodSeconds
                }
            }))
        } catch (err) {
            console.log("failed to renew sub", sub.subId)
            console.log(err)
            return
        }
        openNotification("top", "Success", "Subscription renewed.");
    }

    return null
}