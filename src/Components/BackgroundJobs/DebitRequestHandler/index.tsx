import { useCallback, useEffect, useMemo, useState } from "react";
import { useHistory } from "react-router";
import * as Types from "../../../Api/pub/autogenerated/ts/types";
import { SourceDebitRequest } from "../../../globalTypes";
import { getNostrClient, parseNprofile } from "../../../Api/nostr";
import { selectNostrSpends, useSelector } from "../../../State/store";
import { Modal } from "../../Modals/Modal";
import { decodeInvoice, NOSTR_RELAYS, parseBitcoinInput } from "../../../constants";
import { nip19 } from "nostr-tools";
import styles from "./styles/index.module.scss";
import { CrossIcon, ShieldIcon } from '../../../Assets/SvgIconLibrary';
import Dropdown from "../../Dropdowns/LVDropdown";
import { getDebitAppNameAndAvatarUrl, intervalTypeToUnit, unitToIntervalType, unitToMilliSeconds, WalletIntervalEnum } from "./helpers";
import Checkbox from "../../Checkbox";
import classNames from "classnames";

const intervalsArray = Object.values(WalletIntervalEnum);

const formatNumberWithCommas = (num: string) => {
	return num.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
};



export const DebitRequestHandler = () => {
	const history = useHistory();
	const price = useSelector((state) => state.usdToBTC);
	const nostrSpends = useSelector(selectNostrSpends);
	const nodedUp = useSelector(state => state.nostrPrivateKey);

	// request info
	const [requestData, setRequestData] = useState<SourceDebitRequest | null>(null);
	const [frequencyRule, setFrequencyRule] = useState<Types.FrequencyRule>({
		amount: 100,
		interval: Types.IntervalType.MONTH,
		number_of_intervals: 3
	});

	const [expirationRule, setExpirationRule] = useState<{ unit: WalletIntervalEnum, numberOfUnits: number }>({
		unit: WalletIntervalEnum.MONTH,
		numberOfUnits: 1
	})
	const [requestAmount, setRequestAmount] = useState("")
	const [isSecondPhase, setIsSecondPhase] = useState(false);

	// Display requestor name and avatar
	const [requestorDomain, setRequestorDomain] = useState("");
	const [requestorAvatarUrl, setRequestorAvatarUrl] = useState("");


	const [isRecurringPayment, setIsRecurringPayment] = useState(false);
	const [isExpirationRule, setIsExpirationRule] = useState(false);
	const [adjustForExchangeRate, setAdjustForExchangeRate] = useState(false);

	const [isCreateRule, setIsCreateRule] = useState(true);


	const otherOptions = intervalsArray.filter(i => i !== intervalTypeToUnit(frequencyRule.interval))
	const otherOptionsExpiration = intervalsArray.filter(i => i !== expirationRule.unit)




	useEffect(() => {
		if (!nodedUp) {
			return;
		}
		nostrSpends.forEach(source => {
			const { pubkey, relays } = parseNprofile(source.pasteField)
			getNostrClient({ pubkey, relays }, source.keys).then(c => {
				c.GetLiveDebitRequests(debitReq => {
					console.log("got request")
					if (debitReq.status === "OK") {
						setRequestData({ request: debitReq, source })
						if (debitReq.debit.type === Types.LiveDebitRequest_debit_type.FREQUENCY) {
							setFrequencyRule(debitReq.debit.frequency);
							setRequestAmount(debitReq.debit.frequency.amount.toString())
							setIsRecurringPayment(true);
						} else {
							const { amount } = decodeInvoice(debitReq.debit.invoice)
							setRequestAmount(amount.toString())
						}
					}
				})
			})
		});

	}, [nostrSpends, nodedUp])

	// when a request is received try to fetch a nip05 for the requestor pubkey and get the domain.
	// the domain will be used to supplement the data dispayed in the debit request modal, such as domain name and avatar
	useEffect(() => {
		if (!requestData) {
			setIsSecondPhase(false)
		}
		const getAppNameAndAvatar = async () => {
			if (!requestData) return;

			// TODO: Have the request include a relay to fetch metadata from.
			// For now the code just uses the relay of the source receiving the nip68 request.
			// Note: SMART is supposed to handle this later
			const { requestorDomain: rd, avatarUrl } =  await getDebitAppNameAndAvatarUrl(requestData.request.npub, parseNprofile(requestData.source.pasteField).relays || NOSTR_RELAYS)
			setRequestorDomain(rd)
			setRequestorAvatarUrl(avatarUrl)
		};

		getAppNameAndAvatar();

	}, [requestData])

	const authroizeRequest = useCallback(async (request: SourceDebitRequest) => {
		const rules: Types.DebitRule[] = [];
		if (isRecurringPayment) {
			rules.push({
				rule: {
					type: Types.DebitRule_rule_type.FREQUENCY_RULE,
					frequency_rule: frequencyRule
				}
			})
		}

		if (isExpirationRule) {
			rules.push({
				rule: {
					type: Types.DebitRule_rule_type.EXPIRATION_RULE,
					expiration_rule: { expires_at_unix: Date.now() + (unitToMilliSeconds(expirationRule.unit) * expirationRule.numberOfUnits) }
				}
			})
		}
		if (request.request.debit.type === Types.LiveDebitRequest_debit_type.INVOICE && !isRecurringPayment && !isExpirationRule) {
			const invoice = request.request.debit.invoice
			const parsed = await parseBitcoinInput(invoice)
			history.push({
				pathname: "/send",
				state: parsed
			})
			return
		}
		console.log({rules})
		const res = await (await getNostrClient(request.source.pasteField, request.source.keys)).AuthorizeDebit({
			authorize_npub: request.request.npub, rules
		});
		if (res.status !== "OK") {
			throw new Error(res.reason);
		}
		setRequestData(null)
	}, [history, isExpirationRule, isRecurringPayment, frequencyRule, expirationRule]);

	const banRequest = useCallback(async (request: SourceDebitRequest) => {
		const res = await (await getNostrClient(request.source.pasteField, request.source.keys)).BanDebit({ npub: request.request.npub });
		if (res.status !== "OK") {
			throw new Error(res.reason);
		}
		setRequestData(null)
	}, [])

	const substrinedNpub = useMemo(() => {
		if (!requestData) return "";
		const npub = nip19.npubEncode(requestData.request.npub);
		return `${npub.substring(0, 20)}...${npub.substring(npub.length - 20, npub.length)}`
	}, [requestData])


	const handleFirstPhaseAllow = useCallback((request: SourceDebitRequest) => {
		if (isCreateRule) {
			setIsSecondPhase(true);
		} else {
			authroizeRequest(request)
		}
	}, [authroizeRequest, isCreateRule])

	const modalContent = requestData ? (
		<div className={styles["container"]}>
			<div className={styles["header"]}>Incoming Request</div>
			<div className={styles["requestor-container"]}>
				{
					requestorAvatarUrl
					&&
					<img src={requestorAvatarUrl} alt="Requestor avatar" height={55} width={55} />
				}
				{
					requestorDomain
					&&
					<span className={styles["app-name"]}>{requestorDomain}</span>
				}
				<span className={styles["npub"]}>{substrinedNpub}</span>
			</div>

			<>
				{
					!isSecondPhase
						?
						<>
							<div className={styles["debit-info"]}>
								<span className={styles["orange-text"]}>Wants you to spend</span>
								<span className={styles["sats-amount"]}>{new Intl.NumberFormat('en-US').format(+requestAmount)}</span>
								<span className={styles["fiat"]}>~ $ {+requestAmount === 0 ? 0 : (+requestAmount * price.buyPrice * 0.00000001).toFixed(2)}</span>
							</div>
							<div className={styles["buttons-container"]}>
								<button onClick={() => setRequestData(null)}>
									<>
										<CrossIcon />
										Deny
									</>
								</button>
								<button onClick={() => handleFirstPhaseAllow(requestData)}>
									<>
										<ShieldIcon />
										Allow
									</>
								</button>
							</div>
							<div className={styles["buttons-container"]}>
							<button onClick={() => banRequest(requestData)}>Ban</button>
							</div>
							<div className={styles["checkbox-container"]}>
									<Checkbox state={isCreateRule} setState={(e) => setIsCreateRule(e.target.checked)} id="create-rule" />
									<span>Create rules for this app.</span>
								</div>
						</>
						:
						<>
							<div className={styles["debit-info"]}>
								<span className={styles["orange-text"]}>Budget before network fees:</span>

								<input
									className={classNames(styles["input"], styles["sats-amount-input"])}
									type="text"
									value={formatNumberWithCommas(requestAmount)}
									onChange={(e) => {
										console.log({ s: e.target.value })
										const rawInput = e.target.value.replace(/,/g, '');
										console.log({ rawInput })
										if (rawInput === '' || !isNaN(+rawInput)) {
											setRequestAmount(rawInput)
										}
									}}

								/>

								<span className={styles["fiat"]}>~ $ {+requestAmount === 0 ? 0 : (+requestAmount * price.buyPrice * 0.00000001).toFixed(2)}</span>
								<div className={styles["checkbox-container"]}>
									<Checkbox state={isRecurringPayment} setState={(e) => setIsRecurringPayment(e.target.checked)} id="recurring-payment" />
									<span>Recurring payment:</span>
								</div>
								<div className={classNames({
									[styles["rule-options"]]: true,
									[styles["disabled"]]: !isRecurringPayment
								})}>
									<span>Reset budget every</span>
									<input className={classNames(styles["input"], styles["num-intervals-input"])} type="number" min={1} value={frequencyRule.number_of_intervals} onChange={(e) => setFrequencyRule(state => ({ ...state, number_of_intervals: +e.target.value }))} />
									<Dropdown<WalletIntervalEnum>
										setState={(value) => setFrequencyRule(state => ({ ...state, interval: unitToIntervalType(value) }))}
										otherOptions={otherOptions}
										jsx={
											<div className={styles["dropdown-box"]}>{intervalTypeToUnit(frequencyRule.interval)} ▼</div>
										}
									/>
								</div>

								<div className={styles["checkbox-container"]}>
									<Checkbox state={isExpirationRule} setState={(e) => setIsExpirationRule(e.target.checked)} id="expiration-rule" />
									<span>Expiration rule:</span>
								</div>
								<div className={classNames({
									[styles["rule-options"]]: true,
									[styles["disabled"]]: !isExpirationRule
								})}>
									<span>Expire debit</span>
									<input className={classNames(styles["input"], styles["num-intervals-input"])} type="number" min={1} value={expirationRule.numberOfUnits} onChange={(e) => setExpirationRule(state => ({ ...state, numberOfUnits: +e.target.value }))} />
									<Dropdown<WalletIntervalEnum>
										setState={(value) => setExpirationRule(state => ({ ...state, unit: value }))}
										otherOptions={otherOptionsExpiration}
										jsx={
											<div className={styles["dropdown-box"]}>{expirationRule.unit} ▼</div>
										}
									/>
									<span>from now</span>
								</div>

								<div className={styles["adjust-checkbox-container"]}>
									<Checkbox state={adjustForExchangeRate} setState={(e) => setAdjustForExchangeRate(e.target.checked)} id="adjust-for-rate" />
									<p>
										Periodically adjust for changes in exchange rate
										&#40;experimental, wallet client must be active&#41
									</p>
								</div>
							</div>
							<div className="Sources_modal_add_btn">
								<button onClick={() => setRequestData(null)}>
									<>
										<CrossIcon />
										Deny
									</>
								</button>
								<button onClick={() => authroizeRequest(requestData)}>

									<>
										<ShieldIcon />
										Save
									</>
								</button>
							</div>

						</>
				}
			</>

		</div>
	) : <></>;


	if (!requestData) {
		return null
	}

	return <Modal isShown={!!requestData} hide={() => setRequestData(null)} modalContent={modalContent} headerText={''} />
}