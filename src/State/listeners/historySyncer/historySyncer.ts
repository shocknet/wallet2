import { getNostrClient } from "@/Api/nostr";
import { docsSelectors, metadataSelectors, selectCursorForSource, sourcesActions } from "@/State/scoped/backups/sources/slice";
import { selectHealthyNprofileViews } from "@/State/scoped/backups/sources/selectors";
import type { Satoshi } from "@/lib/types/units";
import { ListenerSpec } from "@/State/listeners/lifecycle/lifecycle";
import { historyFetchAllRequested, historyFetchSourceRequested } from "@/State/listeners/actions";
import { isAnyOf, TaskAbortError, TaskResult } from "@reduxjs/toolkit";
import logger from "@/Api/helpers/logger";
import { UserOperation } from "@/Api/pub/autogenerated/ts/types";
import { emptyCursor, parseOperationsResponse } from "@/State/scoped/backups/sources/history/helpers";
import { createDeferred } from "@/lib/deferred";
import { BEACON_STALE_OLDER_THAN } from "@/State/scoped/backups/sources/state";

const inflightBySource = new Map<string, Promise<[TaskResult<void>, TaskResult<void>]>>();

export const historySyncerSpec: ListenerSpec = {
	name: "historySyncer",
	listeners: [
		(add) =>
			add({
				actionCreator: historyFetchSourceRequested,
				effect: async (action, listenerApi) => {
					const { sourceId, deferred } = action.payload;

					const existing = inflightBySource.get(sourceId);
					if (existing) {
						existing.then(() => deferred.resolve(), () => deferred.reject()); // hook deferred promise to existing ongoing fetch for this sourceId
						return;
					}

					const state = listenerApi.getState();
					const view = selectHealthyNprofileViews(state).find(v => v.sourceId === sourceId);
					if (!view) throw new Error(`Source not found: ${sourceId}`);

					const fetchBalanceTask = listenerApi.fork(async forkApi => {
						try {
							const client = await forkApi.pause(getNostrClient({ pubkey: view.lpk, relays: view.relays }, view.keys));

							const infoRes = await forkApi.pause(client.GetUserInfo());
							if (infoRes.status !== "OK") throw new Error(infoRes.reason);

							if (!forkApi.signal.aborted) {
								listenerApi.dispatch(
									sourcesActions.setBalance({
										sourceId,
										balance: {
											balance: infoRes.balance as Satoshi,
											maxWithdrawable: infoRes.max_withdrawable as Satoshi,
										},
									})
								);

								listenerApi.dispatch(
									sourcesActions.setNdebit({ sourceId, ndebit: infoRes.ndebit })
								);
							}
						} catch (err) {
							if (err instanceof TaskAbortError) {
								logger.info(`[${historySyncerSpec.name}] cancelled normally`)
							} else if (err instanceof Error) {
								logger.error(`[${historySyncerSpec.name}] error: ${err.message}`)
							}
						}
					});

					const fetchTransactionsTask = listenerApi.fork(async forkApi => {
						try {
							const client = await forkApi.pause(getNostrClient({ pubkey: view.lpk, relays: view.relays }, view.keys));

							const newOps: UserOperation[] = [];

							let needMore = true;
							let populatedCursor = selectCursorForSource(listenerApi.getState(), view.sourceId) ?? emptyCursor();

							while (needMore) {
								const res = await forkApi.pause(client.GetUserOperations(populatedCursor));
								if (res.status !== "OK") throw new Error(res.reason);

								const { newCursor, operations, needMoreData } = parseOperationsResponse(res, populatedCursor);
								newOps.push(...operations);
								populatedCursor = newCursor;
								needMore = needMoreData;
							}

							if (!forkApi.signal.aborted) {
								listenerApi.dispatch(sourcesActions.mergePage({ sourceId, operations: newOps, newCursor: populatedCursor }))
							}
						} catch (err) {
							if (err instanceof TaskAbortError) {
								logger.info(`[${historySyncerSpec.name}] cancelled normally`)
							} else if (err instanceof Error) {
								logger.error(`[${historySyncerSpec.name}] error: ${err.message}`)
							}
						}
					})

					const tasks = Promise.all([fetchBalanceTask.result, fetchTransactionsTask.result]);

					inflightBySource.set(sourceId, tasks)

					try {
						await tasks;
						deferred.resolve();
					} catch (err) {
						deferred.reject(err);
					} finally {
						inflightBySource.delete(sourceId);
					}
				},
			}),
		(add) =>
			add({
				actionCreator: historyFetchAllRequested,
				effect: async (action, listenerApi) => {
					const views = selectHealthyNprofileViews(listenerApi.getState());
					const promises = []
					for (const v of views) {
						const deferred = createDeferred<TaskResult<void>>();
						promises.push(deferred);
						listenerApi.dispatch(historyFetchSourceRequested({ sourceId: v.sourceId, deferred }));
					}
					await Promise.allSettled(promises)
					action.payload.deferred.resolve();
				},
			}),
		(add) =>
			add({
				matcher: isAnyOf(
					sourcesActions.applyRemoteSource,
					sourcesActions._createDraftDoc,
					sourcesActions.setRelayPresence,
				),
				effect: (action, listenerApi) => {
					const { sourceId } = action.payload as { sourceId: string };

					if (!sourceId) return

					if (sourcesActions.applyRemoteSource.match(action)) {
						const state = listenerApi.getState();
						const source = docsSelectors.selectById(state, sourceId)

						if (!source || source.draft.deleted.value || Date.now() - metadataSelectors.selectById(state, sourceId).lastSeenAtMs > BEACON_STALE_OLDER_THAN) {
							return;
						}
					}

					const deferred = createDeferred<TaskResult<void>>();
					listenerApi.dispatch(historyFetchSourceRequested({ sourceId, deferred }));
				},
			})
	],
}

