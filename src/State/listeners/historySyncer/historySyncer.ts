import { getNostrClient } from "@/Api/nostr";
import { historySelectors, selectCursorForSource, sourcesActions } from "@/State/scoped/backups/sources/slice";
import { selectNprofileViews, selectSourceViewById } from "@/State/scoped/backups/sources/selectors";
import type { Satoshi } from "@/lib/types/units";
import { ListenerSpec } from "@/State/listeners/lifecycle/lifecycle";
import { historyFetchAllRequested, historyFetchSourceRequested, listenerKick } from "@/State/listeners/actions";
import { isAnyOf, TaskAbortError, TaskResult } from "@reduxjs/toolkit";
import { UserOperation } from "@/Api/pub/autogenerated/ts/types";
import { emptyCursor, parseOperationsResponse, payInvoiceReponseToUserOperation, } from "@/State/scoped/backups/sources/history/helpers";
import { createDeferred } from "@/lib/deferred";
import dLogger from "@/Api/helpers/debugLog";
import { becameFresh, exists, isFresh, isNprofile, justAdded } from "../predicates";
import { AppDispatch } from "@/State/store/store";
import { runtimeActions } from "@/State/runtime/slice";
import { SourceType } from "@/State/scoped/common";


const inflightBySource = new Map<string, Promise<[TaskResult<void>, TaskResult<void>]>>();

const startFetchForSource = (sourceId: string, dispatch: AppDispatch) => {
	const deferred = createDeferred<TaskResult<void>>();
	dispatch(historyFetchSourceRequested({ sourceId, deferred }));
}

export const historySyncerSpec: ListenerSpec = {
	name: "historySyncer",
	listeners: [
		(add) =>
			add({
				actionCreator: historyFetchSourceRequested,
				effect: async (action, listenerApi) => {
					const { sourceId, deferred } = action.payload;

					const log = dLogger.withContext({
						procedure: "history-syncer",
						data: { sourceId }
					});

					const existing = inflightBySource.get(sourceId);
					if (existing) {
						log.info("found existing fetch for this source");
						existing.then(() => deferred.resolve(), () => deferred.reject()); // hook deferred promise to existing ongoing fetch for this sourceId
						return;
					}

					const state = listenerApi.getState();
					const view = selectNprofileViews(state).find(v => v.sourceId === sourceId);
					if (!view) {
						log.error("Source not found");
						throw new Error(`Source not found: ${sourceId}`);
					}

					const fetchBalanceTask = listenerApi.fork(async forkApi => {
						try {
							const client = await forkApi.pause(getNostrClient({ pubkey: view.lpk, relays: view.relays }, view.keys));

							const infoRes = await forkApi.pause(client.GetUserInfo());
							if (infoRes.status !== "OK") throw new Error(infoRes.reason);

							if (!forkApi.signal.aborted) {
								listenerApi.dispatch(
									sourcesActions.setBalance({
										sourceId,
										balance: {
											balance: infoRes.balance as Satoshi,
											maxWithdrawable: infoRes.max_withdrawable as Satoshi,
										},
									})
								);

								listenerApi.dispatch(
									sourcesActions.setNdebit({ sourceId, ndebit: infoRes.ndebit })
								);
							}
						} catch (err) {
							if (err instanceof TaskAbortError) {
								log.info("balance fetch task aborted", { error: err });
							} else {
								log.error("error fetching source balance", { error: err });
							}
						}
					});

					const fetchTransactionsTask = listenerApi.fork(async forkApi => {
						try {
							const client = await forkApi.pause(getNostrClient({ pubkey: view.lpk, relays: view.relays }, view.keys));

							const newOps: UserOperation[] = [];

							let needMore = true;
							let populatedCursor = selectCursorForSource(listenerApi.getState(), view.sourceId) ?? emptyCursor();

							while (needMore) {
								const res = await forkApi.pause(client.GetUserOperations(populatedCursor));
								if (res.status !== "OK") throw new Error(res.reason);

								const { newCursor, operations, needMoreData } = parseOperationsResponse(res, populatedCursor);
								newOps.push(...operations);
								populatedCursor = newCursor;
								needMore = needMoreData;
							}

							if (!forkApi.signal.aborted) {
								listenerApi.dispatch(sourcesActions.mergePage({ sourceId, operations: newOps, newCursor: populatedCursor }))
							}
						} catch (err) {
							if (err instanceof TaskAbortError) {
								log.info("transactions fetch task aborted", { error: err });
							} else if (err instanceof Error) {
								log.error("error fetching source transactions", { error: err });
							}
						}
					})

					const tasks = Promise.all([fetchBalanceTask.result, fetchTransactionsTask.result]);

					inflightBySource.set(sourceId, tasks)

					try {
						await tasks;
						deferred.resolve();
					} catch (err) {
						deferred.reject(err);
					} finally {
						inflightBySource.delete(sourceId);
					}
				},
			}),
		(add) =>
			add({
				actionCreator: historyFetchAllRequested,
				effect: async (action, listenerApi) => {
					const views = selectNprofileViews(listenerApi.getState());
					const promises = []
					for (const v of views) {
						const deferred = createDeferred<TaskResult<void>>();
						promises.push(deferred);
						listenerApi.dispatch(historyFetchSourceRequested({ sourceId: v.sourceId, deferred }));
					}
					await Promise.allSettled(promises)
					action.payload.deferred.resolve();
				},
			}),
		// On idenity load, kick all sources history fetch
		(add) =>
			add({
				actionCreator: listenerKick,
				effect: async (_, listenerApi) => {
					const deferred = createDeferred<void>();
					listenerApi.dispatch(historyFetchAllRequested({ deferred }));
					await deferred;
				},
			}),
		// relays set changed
		(add) =>
			add({
				predicate: (action, curr) =>
				(
					sourcesActions.setRelayPresence.match(action) &&
					exists(curr, action.payload.sourceId) &&
					isFresh(curr, action.payload.sourceId)
				),
				effect: (action, listenerApi) => {
					const { sourceId } = action.payload as { sourceId: string };
					startFetchForSource(sourceId, listenerApi.dispatch);
				},
			}),
		// Source just newly added, or source just became fresh
		(add) =>
			add({
				predicate: (action, curr, prev) =>
				(
					(
						isAnyOf(sourcesActions.applyRemoteSource, sourcesActions._createDraftDoc)(action) &&
						exists(curr, action.payload.sourceId) &&
						isNprofile(curr, action.payload.sourceId) &&
						justAdded(curr, prev, action.payload.sourceId) &&
						isFresh(curr, action.payload.sourceId)
					)
					||
					(
						sourcesActions.recordBeaconForSource.match(action) &&
						exists(curr, action.payload.sourceId) &&
						becameFresh(curr, prev, action.payload.sourceId)
					)
				),
				effect: (action, listenerApi) => {
					const { sourceId } = action.payload as { sourceId: string };
					startFetchForSource(sourceId, listenerApi.dispatch);
				},
			}),
		// On app boot or resume, fetch the state of each optimistic operation
		(add) =>
			add({
				predicate: (action) => {
					return listenerKick.match(action) || (runtimeActions.setAppActiveStatus.match(action) && action.payload.active)
				},
				effect: async (_, listenerApi) => {
					const state = listenerApi.getState();
					const allOperations = historySelectors.selectAll(state);

					const optimisticOperations = allOperations.filter(o => !!o.optimistic && o.type === "INVOICE");


					const task = listenerApi.fork(async forkApi => {

						optimisticOperations.map(async o => {

							const sourceId = o.sourceId;
							const invoice = o.invoice;
							const state = listenerApi.getState();

							const log = dLogger.withContext({
								procedure: "optimistic check",
								data: { sourceId, invoice }
							});


							const source = selectSourceViewById(state, sourceId);
							if (!source || source.type !== SourceType.NPROFILE_SOURCE) return null;

							try {
								const client = await forkApi.pause(getNostrClient({ pubkey: source.lpk, relays: source.relays }, source.keys));
								const res = await forkApi.pause(client.GetPaymentState({ invoice }));

								if (res.status !== "OK" || forkApi.signal.aborted) return null;
								if (res.paid_at_unix > 0) {
									listenerApi.dispatch(
										sourcesActions.replaceOptimistic({
											sourceId,
											oldOperationId: invoice,
											operation: payInvoiceReponseToUserOperation({ ...res, amount_paid: res.amount, preimage: res.preimage || "" }, o)
										})
									);
								} else if (res.paid_at_unix < 0) {
									sourcesActions.removeOptimistic({
										sourceId,
										operationId: invoice
									});
								}

							} catch (err) {
								log.error("failed", { error: err });
							}
						})
					});

					await task.result;
				},
			}),

	],
}

