import { getNostrClient } from "@/Api/nostr";
import { docsSelectors, metadataSelectors, selectCursorForSource, sourcesActions } from "@/State/scoped/backups/sources/slice";
import { selectNprofileViews } from "@/State/scoped/backups/sources/selectors";
import type { Satoshi } from "@/lib/types/units";
import { ListenerSpec } from "@/State/listeners/lifecycle/lifecycle";
import { historyFetchAllRequested, historyFetchSourceRequested } from "@/State/listeners/actions";
import { isAnyOf, TaskAbortError, TaskResult } from "@reduxjs/toolkit";
import { UserOperation } from "@/Api/pub/autogenerated/ts/types";
import { emptyCursor, parseOperationsResponse } from "@/State/scoped/backups/sources/history/helpers";
import { createDeferred } from "@/lib/deferred";
import { isNewSourceAddition, isNprofileSource, isSourceDeleted, isSourceStale } from "@/State/utils";
import dLogger from "@/Api/helpers/debugLog";

const inflightBySource = new Map<string, Promise<[TaskResult<void>, TaskResult<void>]>>();

export const historySyncerSpec: ListenerSpec = {
	name: "historySyncer",
	listeners: [
		(add) =>
			add({
				actionCreator: historyFetchSourceRequested,
				effect: async (action, listenerApi) => {
					const { sourceId, deferred } = action.payload;

					const log = dLogger.withContext({
						procedure: "history-syncer",
						data: { sourceId }
					});

					const existing = inflightBySource.get(sourceId);
					if (existing) {
						log.info("found existing fetch for this source");
						existing.then(() => deferred.resolve(), () => deferred.reject()); // hook deferred promise to existing ongoing fetch for this sourceId
						return;
					}

					const state = listenerApi.getState();
					const view = selectNprofileViews(state).find(v => v.sourceId === sourceId);
					if (!view) {
						log.error("Source not found");
						throw new Error(`Source not found: ${sourceId}`);
					}

					const fetchBalanceTask = listenerApi.fork(async forkApi => {
						try {
							const client = await forkApi.pause(getNostrClient({ pubkey: view.lpk, relays: view.relays }, view.keys));

							const infoRes = await forkApi.pause(client.GetUserInfo());
							if (infoRes.status !== "OK") throw new Error(infoRes.reason);

							if (!forkApi.signal.aborted) {
								listenerApi.dispatch(
									sourcesActions.setBalance({
										sourceId,
										balance: {
											balance: infoRes.balance as Satoshi,
											maxWithdrawable: infoRes.max_withdrawable as Satoshi,
										},
									})
								);

								listenerApi.dispatch(
									sourcesActions.setNdebit({ sourceId, ndebit: infoRes.ndebit })
								);
							}
						} catch (err) {
							if (err instanceof TaskAbortError) {
								log.info("balance fetch task aborted", { error: err });
							} else {
								log.error("error fetching source balance", { error: err });
							}
						}
					});

					const fetchTransactionsTask = listenerApi.fork(async forkApi => {
						try {
							const client = await forkApi.pause(getNostrClient({ pubkey: view.lpk, relays: view.relays }, view.keys));

							const newOps: UserOperation[] = [];

							let needMore = true;
							let populatedCursor = selectCursorForSource(listenerApi.getState(), view.sourceId) ?? emptyCursor();

							while (needMore) {
								const res = await forkApi.pause(client.GetUserOperations(populatedCursor));
								if (res.status !== "OK") throw new Error(res.reason);

								const { newCursor, operations, needMoreData } = parseOperationsResponse(res, populatedCursor);
								newOps.push(...operations);
								populatedCursor = newCursor;
								needMore = needMoreData;
							}

							if (!forkApi.signal.aborted) {
								listenerApi.dispatch(sourcesActions.mergePage({ sourceId, operations: newOps, newCursor: populatedCursor }))
							}
						} catch (err) {
							if (err instanceof TaskAbortError) {
								log.info("transactions fetch task aborted", { error: err });
							} else if (err instanceof Error) {
								log.error("error fetching source transactions", { error: err });
							}
						}
					})

					const tasks = Promise.all([fetchBalanceTask.result, fetchTransactionsTask.result]);

					inflightBySource.set(sourceId, tasks)

					try {
						await tasks;
						deferred.resolve();
					} catch (err) {
						deferred.reject(err);
					} finally {
						inflightBySource.delete(sourceId);
					}
				},
			}),
		(add) =>
			add({
				actionCreator: historyFetchAllRequested,
				effect: async (action, listenerApi) => {
					const views = selectNprofileViews(listenerApi.getState());
					const promises = []
					for (const v of views) {
						const deferred = createDeferred<TaskResult<void>>();
						promises.push(deferred);
						listenerApi.dispatch(historyFetchSourceRequested({ sourceId: v.sourceId, deferred }));
					}
					await Promise.allSettled(promises)
					action.payload.deferred.resolve();
				},
			}),
		// set relay presence called, or new source addition
		(add) =>
			add({
				predicate: (action, curr, prev) => {
					if (sourcesActions.setRelayPresence.match(action)) return true;


					if (!isAnyOf(
						sourcesActions.applyRemoteSource,
						sourcesActions._createDraftDoc,
					)(action))
						return false;

					const { sourceId } = action.payload;
					const isSourceAddition = isNewSourceAddition(curr, prev, sourceId);


					if (!isSourceAddition) return false;

					const source = docsSelectors.selectById(curr, sourceId)?.draft;
					if (!isNprofileSource(source))
						return false;
					return true;
				},
				effect: (action, listenerApi) => {
					const { sourceId } = action.payload as { sourceId: string };

					const deferred = createDeferred<TaskResult<void>>();
					listenerApi.dispatch(historyFetchSourceRequested({ sourceId, deferred }));
				},
			}),
		// Source was stale; became unstale
		(add) =>
			add({
				predicate: (action, curr, prev) => {
					if (!sourcesActions.recordBeaconForSource.match(action)) return false;

					const { sourceId } = action.payload;

					const source = docsSelectors.selectById(curr, sourceId)?.draft;

					if (!isNprofileSource(source) || isSourceDeleted(source)) {
						return false;
					}

					// was stale and just became non stale
					return isSourceStale(metadataSelectors.selectById(prev, sourceId)) && !isSourceStale(metadataSelectors.selectById(curr, sourceId))
				},
				effect: (action, listenerApi) => {
					const { sourceId } = action.payload as { sourceId: string };

					const deferred = createDeferred<TaskResult<void>>();
					listenerApi.dispatch(historyFetchSourceRequested({ sourceId, deferred }));
				},
			})
	],
}

