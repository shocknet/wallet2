import { createSelector, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { bump, bumpFlag, eqFlags, eqLww, mergeFlags, mergeLww } from "../lww";
import { type SourceDocV0 } from "./schema";
import { RootState } from "@/State/store/store";
import { getPersistConfigKey, makeScopedPersistedReducer } from "@/State/persist/scope";
import IonicStorageAdapter from "@/storage/redux-persist-ionic-storage-adapter";
import { selectScopedStrict } from "../../stricScopedSelector";
import { SourceType } from "../../common";
import { docsAdapter, getIntialState, metadataAdapter, opsAdapter, SourcesState } from "./state";
import { breakKey, emptyCursor, makeKey, userOperationToSourceOperation } from "./history/helpers";
import { BalanceMeta, BeaconMeta } from "./metadata/types";
import { UserOperation } from "@/Api/pub/autogenerated/ts/types";
import { HistoryCursor, SourceActualOperation, SourceOperation, SourceOptimsticOperation } from "./history/types";






const mergeSourceDoc = (b: SourceDocV0, r: SourceDocV0) => {
	const base: SourceDocV0 = { ...b, label: mergeLww<string | null>(b.label, r.label), deleted: mergeLww<boolean>(b.deleted, r.deleted) }
	if (b.type === SourceType.NPROFILE_SOURCE && r.type === SourceType.NPROFILE_SOURCE) {
		base.relays = mergeFlags(b.relays, r.relays);
		base.admin_token = mergeLww(b.admin_token, r.admin_token);
		base.is_ndebit_discoverable = mergeLww(b.is_ndebit_discoverable, r.is_ndebit_discoverable);
	}
	return base;
}
function equalSourceDoc(a?: SourceDocV0, b?: SourceDocV0): boolean {
	if (!a || !b) return false;

	if (!eqLww(a.label, b.label)) return false;
	if (!eqLww(a.deleted, b.deleted)) return false;

	if (a.type === SourceType.NPROFILE_SOURCE && b.type === SourceType.NPROFILE_SOURCE) {
		if (!eqFlags(a.relays, b.relays)) return false;
		if (!eqLww(a.admin_token, b.admin_token)) return false;
		if (!eqLww(a.is_ndebit_discoverable, b.is_ndebit_discoverable)) return false;
	}

	return true;
}

function deletionWins(d: SourceDocV0) {
	const delV = d.deleted.clock.v
	const vs = [d.label.clock.v]
	if (d.type === SourceType.NPROFILE_SOURCE) {
		vs.push(
			...Object.values(d.relays).map(f => f.clock.v),
			d.is_ndebit_discoverable.clock.v,
			d.admin_token.clock.v
		)
	}
	return delV >= Math.max(...vs, 0)
}

function ensureHistoryIndex(state: SourcesState, sourceId: string) {
	return (state.history.bySource[sourceId] ??= { ids: [], cursor: emptyCursor() })
}



export const sourcesSlice = createSlice({
	name: "sources",
	initialState: getIntialState(),
	reducers: {
		/** --------- DOCS --------- */
		_createDraftDoc(state, a: PayloadAction<{ sourceId: string, draft: SourceDocV0 }>) {
			const d = a.payload.draft;
			if (state.docs.entities[d.source_id]) return;
			docsAdapter.addOne(state.docs, {
				draft: d,
				dirty: true,
			});
			metadataAdapter.upsertOne(state.metadata, { type: d.type, id: d.source_id })
			ensureHistoryIndex(state, d.source_id)
		},

		/**
		 * Local mark-delete (tombstone). We DON"T remove immediately.
		 * UI hide if draft.deleted.value === true.
		 * Actual purge happens on `ackPublished` or when a remote tombstone wins.
		 */
		markDeleted(state, a: PayloadAction<{ sourceId: string; by: string }>) {
			const e = state.docs.entities[a.payload.sourceId]
			if (!e) return
			if (!e.draft.deleted.value) {
				e.draft.deleted = bump(e.draft.deleted, true, a.payload.by)
				e.dirty = true
			}
		},

		updateSourceLabel(state, a: PayloadAction<{ sourceId: string; label?: string; now: number, by: string }>) {
			const e = state.docs.entities[a.payload.sourceId];
			if (!e) return;
			const d = e.draft;
			if (a.payload.label !== undefined && d.label.value !== a.payload.label) {
				d.label = bump(d.label, a.payload.label, a.payload.by);
			}
			e.dirty = true;
		},

		updateBridgeUrl(state, a: PayloadAction<{ sourceId: string; bridgeUrl: string | null; now: number, by: string }>) {
			const e = state.docs.entities[a.payload.sourceId];
			if (!e) return;
			if (e.draft.type !== SourceType.NPROFILE_SOURCE) return;
			const d = e.draft;
			if (a.payload.bridgeUrl !== undefined && d.bridgeUrl.value !== a.payload.bridgeUrl) {
				d.bridgeUrl = bump(d.bridgeUrl, a.payload.bridgeUrl, a.payload.by);
			}
			e.dirty = true;
		},

		updateisNDebitDiscoverable(state, a: PayloadAction<{ sourceId: string; isNdebitDiscoverable: boolean; now: number, by: string }>) {
			const e = state.docs.entities[a.payload.sourceId];
			if (!e) return;
			if (e.draft.type !== SourceType.NPROFILE_SOURCE) return;
			const d = e.draft;
			if (a.payload.isNdebitDiscoverable !== d.is_ndebit_discoverable.value) {
				d.is_ndebit_discoverable = bump(d.is_ndebit_discoverable, a.payload.isNdebitDiscoverable, a.payload.by);
			}
			e.dirty = true;
		},

		updateAdminToken(state, a: PayloadAction<{ sourceId: string; adminToken: string | null; by: string }>) {
			const e = state.docs.entities[a.payload.sourceId];
			if (!e) return;
			if (e.draft.type !== SourceType.NPROFILE_SOURCE) return;
			const d = e.draft;
			if (a.payload.adminToken !== d.admin_token.value) {
				d.admin_token = bump(d.admin_token, a.payload.adminToken, a.payload.by);
			}
			e.dirty = true;
		},


		setRelayPresence(state, a: PayloadAction<{ sourceId: string; relayUrl: string; present: boolean; by: string; now: number }>) {
			const e = state.docs.entities[a.payload.sourceId];
			if (!e) return;
			if (e.draft.type !== SourceType.NPROFILE_SOURCE) return;
			const relays = e.draft.relays;
			const cur = relays[a.payload.relayUrl];
			if (!cur || cur.present !== a.payload.present) {
				relays[a.payload.relayUrl] = bumpFlag(cur, a.payload.present, a.payload.by);
				e.dirty = true;
			}
		},

		applyRemoteSource(state, a: PayloadAction<{ sourceId: string, remote: SourceDocV0 }>) {
			const r = a.payload.remote;
			const e = state.docs.entities[r.source_id];

			if (!e) {
				if (!r.deleted.value) {
					docsAdapter.addOne(state.docs, { base: r, draft: r, dirty: false });
					metadataAdapter.upsertOne(state.metadata, { type: r.type, id: r.source_id })
					return;
				} else {
					return
				}
			}


			if (e.draft.type !== r.type) return;

			const b = e.base, d = e.draft;

			const basePrime = !b ? r : mergeSourceDoc(b, r);

			const draftPrime = mergeSourceDoc(basePrime, d);

			// If tombstone now dominates, purge everything for this source
			if (draftPrime.deleted.value && deletionWins(draftPrime)) {
				delete state.history.bySource[a.payload.sourceId];
				opsAdapter.removeMany(state.history.ops, state.history.ops.ids.filter(id => breakKey(id)[0] === a.payload.sourceId));

				metadataAdapter.removeOne(state.metadata, a.payload.sourceId);

				docsAdapter.removeOne(state.docs, draftPrime.source_id);
				return;
			}



			e.base = basePrime;
			e.draft = draftPrime;
			e.dirty = !equalSourceDoc(basePrime, draftPrime);
		},

		ackPublished(state, a: PayloadAction<{ sourceId: string; when?: number }>) {
			const e = state.docs.entities[a.payload.sourceId];
			if (!e) return;

			// If we published a tombstone and it dominates locally, purge now
			if (e.draft.deleted.value && deletionWins(e.draft)) {
				const sourceId = a.payload.sourceId
				const idx = state.history.bySource[sourceId]
				if (idx) {
					for (const k of idx.ids) opsAdapter.removeOne(state.history.ops, k)
					delete state.history.bySource[sourceId]
				}
				metadataAdapter.removeOne(state.metadata, sourceId)
				docsAdapter.removeOne(state.docs, sourceId)
				return
			}
			e.base = e.draft;
			e.dirty = false;
			e.lastPublishedAt = a.payload.when ?? Date.now();
		},




		/** --------- METADATA --------- */
		setBeacon(state, a: PayloadAction<{ sourceId: string; beacon: BeaconMeta }>) {
			const m = state.metadata.entities[a.payload.sourceId]
			if (m && m.type === SourceType.NPROFILE_SOURCE) {
				m.beacon = a.payload.beacon
			}
		},
		setVanityName(state, a: PayloadAction<{ sourceId: string; vanityName: string }>) {
			const m = state.metadata.entities[a.payload.sourceId]
			if (m && m.type === SourceType.NPROFILE_SOURCE) {
				m.vanityName = a.payload.vanityName;
			}
		},
		setNdebit(state, a: PayloadAction<{ sourceId: string; ndebit: string }>) {
			const m = state.metadata.entities[a.payload.sourceId]
			if (m && m.type === SourceType.NPROFILE_SOURCE) {
				m.ndebit = a.payload.ndebit;
			}
		},
		clearBeacon(state, a: PayloadAction<{ sourceId: string }>) {
			const m = state.metadata.entities[a.payload.sourceId]
			if (m && m.type === SourceType.NPROFILE_SOURCE) {
				delete m.beacon
			}
		},
		setBalance(state, a: PayloadAction<{ sourceId: string; balance: BalanceMeta }>) {
			const m = state.metadata.entities[a.payload.sourceId]
			if (m && m.type === SourceType.NPROFILE_SOURCE) {
				m.balance = a.payload.balance
			}
		},
		clearBalance(state, a: PayloadAction<{ sourceId: string }>) {
			const m = state.metadata.entities[a.payload.sourceId]
			if (m && m.type === SourceType.NPROFILE_SOURCE) {
				delete m.balance
			}
		},
		setBeaconStaleMs(state, a: PayloadAction<number>) {
			state.metadata.beaconStaleMs = a.payload
		},
		recomputeStale(state) {
			const now = Date.now()
			for (const id of state.metadata.ids as string[]) {
				const m = state.metadata.entities[id]!
				if (m.type === SourceType.NPROFILE_SOURCE && m.beacon) {
					const b = m.beacon
					b.stale = now - b.lastSeenAtMs > state.metadata.beaconStaleMs
				}
			}
		},



		/** --------- OPERATIONS HISTORY --------- */
		mergePage(
			state,
			action: PayloadAction<{
				sourceId: string;
				operations: UserOperation[];
				newCursor: HistoryCursor
			}>
		) {
			const { sourceId, operations, newCursor } = action.payload;
			const idx = ensureHistoryIndex(state, sourceId);

			// Track which opKeys were new to us
			let newlyAdded = 0;

			for (const op of operations) {
				const key = makeKey(sourceId, op.operationId);
				const existing = state.history.ops.entities[key];
				const sourceOperation = userOperationToSourceOperation(op, sourceId, existing)
				opsAdapter.upsertOne(state.history.ops, sourceOperation);
				if (!existing) {
					idx.ids.push(key);
					newlyAdded++;
				} else {
					// id exists; ensure it"s in the index (in case of legacy gaps)
					if (!idx.ids.includes(key)) idx.ids.push(key);
				}
			}

			// Keep local list sorted by paidAtUnix using adapterâ€™s comparator
			// (adapter.sortComparer sorts the entity collection; we mirror with ids)
			idx.ids.sort((ka, kb) => {
				const a = state.history.ops.entities[ka]!;
				const b = state.history.ops.entities[kb]!;
				return b.paidAtUnix - a.paidAtUnix;
			});

			idx.cursor = newCursor;
			if (newlyAdded > 0) state.history.newPaymentsCount += newlyAdded;
		},

		ingestLive(
			state,
			action: PayloadAction<{ sourceId: string; operation: UserOperation }>
		) {
			const { sourceId, operation } = action.payload;
			const idx = ensureHistoryIndex(state, sourceId);
			const key = makeKey(sourceId, operation.operationId);
			const existing = state.history.ops.entities[key];
			const sourceOperation = userOperationToSourceOperation(operation, sourceId, existing)


			opsAdapter.upsertOne(state.history.ops, sourceOperation);
			if (!idx.ids.includes(key)) idx.ids.push(key);

			idx.ids.sort((ka, kb) => {
				const a = state.history.ops.entities[ka]!;
				const b = state.history.ops.entities[kb]!;
				return b.paidAtUnix - a.paidAtUnix;
			});

			if (!existing) state.history.newPaymentsCount += 1;
		},


		addOptimistic(
			state,
			action: PayloadAction<{ sourceId: string; operation: SourceOptimsticOperation }>
		) {
			const { sourceId, operation } = action.payload;
			const idx = ensureHistoryIndex(state, sourceId);
			const key = operation.opKey;

			if (state.history.ops.entities[key]) return; // already there

			opsAdapter.addOne(state.history.ops, operation);
			idx.ids.push(key);
			idx.ids.sort((ka, kb) => {
				const a = state.history.ops.entities[ka]!;
				const b = state.history.ops.entities[kb]!;
				return b.paidAtUnix - a.paidAtUnix;
			});
		},

		replaceOptimistic(
			state,
			action: PayloadAction<{
				sourceId: string;
				oldOperationId: string;
				operation: SourceOptimsticOperation | SourceActualOperation;
			}>
		) {
			const { sourceId, oldOperationId, operation } = action.payload;
			const oldKey = makeKey(sourceId, oldOperationId);
			const newKey = makeKey(sourceId, operation.operationId);

			const idx = ensureHistoryIndex(state, sourceId);

			// Remove old if different key
			if (oldKey !== newKey && state.history.ops.entities[oldKey]) {
				opsAdapter.removeOne(state.history.ops, oldKey);
				const pos = idx.ids.indexOf(oldKey);
				if (pos !== -1) idx.ids.splice(pos, 1);
			}

			// Upsert the new operation
			opsAdapter.upsertOne(state.history.ops, operation);
			if (!idx.ids.includes(newKey)) idx.ids.push(newKey);

			idx.ids.sort((ka, kb) => {
				const a = state.history.ops.entities[ka]!;
				const b = state.history.ops.entities[kb]!;
				return b.paidAtUnix - a.paidAtUnix;
			});
		},

		removeOptimistic(
			state,
			action: PayloadAction<{ sourceId: string; operationId: string }>
		) {
			const { sourceId, operationId } = action.payload;
			const key = makeKey(sourceId, operationId);
			if (!state.history.ops.entities[key]) return;

			opsAdapter.removeOne(state.history.ops, key);
			const idx = ensureHistoryIndex(state, sourceId);
			const pos = idx.ids.indexOf(key);
			if (pos !== -1) idx.ids.splice(pos, 1);
		},


		setOperationNote(
			state,
			action: PayloadAction<{ sourceId: string; operationId: string; note: string }>
		) {
			const { sourceId, operationId, note } = action.payload;
			const key = makeKey(sourceId, operationId);
			const op = state.history.ops.entities[key];
			if (!op) return;

			opsAdapter.updateOne(state.history.ops, { id: key, changes: { memo: note } as Partial<SourceOperation> });
		},


		resetAllCursors(state) {
			// Drop per-source lists and cursors
			for (const sourceId of Object.keys(state.history.bySource)) {
				const idx = state.history.bySource[sourceId];
				for (const key of idx.ids) {
					opsAdapter.removeOne(state.history.ops, key);
				}
				idx.ids = [];
				idx.cursor = emptyCursor();
			}
			state.history.newPaymentsCount = 0;
		},

		clearSourceHistory(state, action: PayloadAction<{ sourceId: string }>) {
			const { sourceId } = action.payload;
			const idx = state.history.bySource[sourceId];
			if (idx) {
				for (const key of idx.ids) opsAdapter.removeOne(state.history.ops, key);
				delete state.history.bySource[sourceId];
			}
		},


		clearHistoryForSources(state, action: PayloadAction<{ sourceIds: string[] }>) {
			for (const sourceId of action.payload.sourceIds) {
				const idx = state.history.bySource[sourceId];
				if (!idx) continue;
				for (const key of idx.ids) opsAdapter.removeOne(state.history.ops, key);
				delete state.history.bySource[sourceId];
			}
		},


		setCursor(
			state,
			action: PayloadAction<{ sourceId: string; cursor: any }>
		) {
			ensureHistoryIndex(state, action.payload.sourceId).cursor = action.payload.cursor;
		},


		incrementNewPayments(state, action: PayloadAction<number | void>) {
			state.history.newPaymentsCount += (action.payload ?? 1);
		},
		resetNewPayments(state) {
			state.history.newPaymentsCount = 0;
		},
	},
});



export function getScopedSourcesReducer(identityPubkey: string) {
	return makeScopedPersistedReducer(
		sourcesSlice.reducer,
		"_sources",
		identityPubkey,
		{
			version: 0,
			storage: IonicStorageAdapter,

		}
	);
}

export function getScopedSourcesPersistKey(identityPubkey: string) {
	return getPersistConfigKey("sources", identityPubkey);
}


export const sourcesActions = sourcesSlice.actions;


export const docsSelectors = docsAdapter.getSelectors<RootState>(
	(state) => selectScopedStrict(state).sources.docs
);

export const metadataSelectors = metadataAdapter.getSelectors<RootState>(
	(state) => selectScopedStrict(state).sources.metadata
);
export const historySelectors = opsAdapter.getSelectors<RootState>(
	(state) => {
		return selectScopedStrict(state).sources.history.ops
	}
);



export const selectIsSourceDocDirty = (state: RootState, sourceId: string) => !!docsSelectors.selectById(state, sourceId)?.dirty


const selectHistorySlice = (state: RootState) => selectScopedStrict(state).sources.history;
export const selectCursorForSource = createSelector(
	[
		selectHistorySlice,
		(_: RootState, sourceId: string) => sourceId,
	],
	(hist, sourceId) => hist.bySource[sourceId]?.cursor ?? null
);
