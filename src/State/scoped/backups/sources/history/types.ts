import type { GetUserOperationsRequest } from "@/Api/pub/autogenerated/ts/types";
import type { ParsedLightningAddressInput, ParsedLnurlPayInput, ParsedNofferInput } from "@/lib/types/parse";
import type { Satoshi } from "@/lib/types/units";


export type OpKey = string; // `${sourceId}/${operationId}`


/* All app source operations are a union type with deep type definitions */
export interface SourceOperationBase {
	opKey: OpKey
	sourceId: string;
	operationId: string;
	paidAtUnix: number;
	amount: Satoshi;
	memo?: string;
	optimistic?: never;
}

export interface OptimisticOperationBase {
	sourceId: string;
	operationId: string;
	paidAtUnix: number;
	amount: Satoshi;
	inbound: false; // Optimistic operations are always outbound
	memo?: string;
	optimistic: true;
}


/* Invoice payments are done by either pub sources (receive or send) and lnurl w sources (send only) */
type SourceOperationInvoiceBase = SourceOperationBase & {
	invoice: string;
	invoiceMemo?: string;
	invoiceSource?: ParsedNofferInput | ParsedLnurlPayInput | ParsedLightningAddressInput; // if the invoice was generated from one these we want to know that
}

export type SourceOperationInvoice =
	| (SourceOperationInvoiceBase & { // Pub source
		type: "INVOICE";
		inbound: boolean;
		serviceFee: number;
	} & (
			| {
				internal: true;
				networkFee?: never
			}
			| {
				internal: false;
				networkFee: number;
			}
		))
	| (SourceOperationInvoiceBase & { // Lnurl w source
		type: "LNURL_WITHDRAW";
		inbound: false; // lnurl withdraws invoice payments are always outgoing
		internal: false;
		// we can't get info about the network fee from the lnurl w source
		serviceFee?: never;
		networkFee?: never;
	})




export type SourceOperationOnChain = SourceOperationBase & {
	type: "ON-CHAIN";
	address: string;
	inbound: boolean;
	serviceFee: number;
} & (
		| {
			internal: true;
			networkFee?: never;
			txHash?: never;
		}
		| {
			internal: false;
			networkFee: number;
			txHash: string;
		}
	)




/* Optimistic operations */

export type SourceOptimsiticInvoice = OptimisticOperationBase & {
	type: "INVOICE";
	invoice: string;
	invoiceMemo?: string;
	inbound: false; // Optimistic operations are always outgoing
	invoiceSource?: ParsedNofferInput | ParsedLnurlPayInput | ParsedLightningAddressInput; // if the invoice was generated from one these we want to know that
}


export type SourceOptimsiticOnChain = OptimisticOperationBase & {
	type: "ON-CHAIN";
	address: string;
	inbound: false; // Optimistic operations are always outgoing

} & (
		// 1) Network request not done
		| {
			internal?: never;
			status: "broadcasting";
			networkFee?: never;
			serviceFee?: never;
			txHash?: never;
		}

		// 2) Network request done => discovered internal => done
		| {
			internal: true;
			status: "success"; // or "done", if you prefer
			networkFee?: never;
			serviceFee: number;
			txHash?: never;
		}

		// 3) Network request done => discovered external => "confirming"
		| {
			internal: false;
			status: "confirming";
			networkFee: number;
			serviceFee: number;
			txHash: string;
		}
	)

export type SourceUserToUserOperation = SourceOperationBase & {
	type: "USER_TO_USER";
	inbound: boolean;
	serviceFee: number;
}

export type SourceOptimsticOperation = SourceOptimsiticInvoice | SourceOptimsiticOnChain;
export type SourceActualOperation = SourceOperationInvoice | SourceOperationOnChain | SourceUserToUserOperation;

export type SourceOperation = SourceActualOperation | SourceOptimsticOperation



export type HistoryCursor = GetUserOperationsRequest




