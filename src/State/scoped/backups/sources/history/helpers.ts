import type { GetUserOperationsResponse, PayInvoiceResponse, } from "@/Api/pub/autogenerated/ts/types";
import { UserOperation, UserOperationType } from "@/Api/pub/autogenerated/ts/types";
import type { HistoryCursor, OpKey, SourceActualOperation, SourceOperation, SourceOperationBase, SourceOperationInvoice, SourceOptimsiticInvoice } from "./types";
import { decodeInvoice } from "@/lib/invoice";
import type { Satoshi } from "@/lib/types/units";

export const makeKey = (sourceId: string, operationId: string): OpKey =>
	`${sourceId}/${operationId}`;

export const breakKey = (key: string) => {

	const [sourceId, operationId] = key.split("/");
	return [sourceId, operationId];
}

// Helper function to convert a UserOperation to a SourceOperation
export const userOperationToSourceOperation = (op: UserOperation, sourceId: string, local?: SourceOperation): SourceActualOperation => {
	const incoming = transformUserOperationToSourceOperation(op, sourceId);
	if (local === undefined) {
		return incoming;
	}

	// Operations may have data that is truly local, like the local memo and the lnurl the
	// invoice was generated from in case of invoice operations. This function makes sure we merge
	// the incoming operation (UserOperation from pub) with the local one, so we don"t lose that data.
	const operation: SourceActualOperation = {
		...incoming,
		operationId: makeKey(sourceId, incoming.operationId),
		memo: local.memo, // preserve local memo
		...((incoming.type === "INVOICE" && local.type === "INVOICE") ? { // preserve local invoice data
			invoiceMemo: local.invoiceMemo,
			invoiceSource: local.invoiceSource,
		} : {}),
	}
	return operation;
}

export const payInvoiceReponseToSourceOperation = (resp: PayInvoiceResponse, optimisticOperation: SourceOptimsiticInvoice): SourceOperationInvoice => {

	const userOperation: UserOperation = {
		operationId: resp.operation_id,
		type: UserOperationType.OUTGOING_INVOICE,
		identifier: optimisticOperation.invoice,
		amount: resp.amount_paid as Satoshi,
		paidAtUnix: Math.floor(Date.now() / 1000), // UserOperation"s paidAtUnix is in seconds
		service_fee: resp.service_fee,
		network_fee: resp.network_fee,
		inbound: false,
		...(resp.preimage === "" // when preimage is empty, it"s an internal payment
			? { internal: true }
			: {
				internal: false,
			}
		),
		confirmed: true,
		tx_hash: ""
	}

	return userOperationToSourceOperation(userOperation, optimisticOperation.sourceId, optimisticOperation) as SourceOperationInvoice;
}


const transformUserOperationToSourceOperation = (op: UserOperation, sourceId: string): SourceActualOperation => {
	const base: SourceOperationBase = {
		opKey: makeKey(sourceId, op.operationId),
		amount: op.amount as Satoshi,
		operationId: op.operationId,
		sourceId,
		paidAtUnix: op.paidAtUnix * 1000,
	}
	switch (op.type) {
		case UserOperationType.INCOMING_INVOICE:
		case UserOperationType.OUTGOING_INVOICE:
			return {
				...base,
				type: "INVOICE",
				invoice: op.identifier,
				inbound: op.type === UserOperationType.INCOMING_INVOICE,
				invoiceMemo: decodeInvoice(op.identifier)?.description,
				serviceFee: op.service_fee,

				...(op.internal
					? { internal: true }
					: {
						internal: false,
						networkFee: op.network_fee
					})
			}
		case UserOperationType.INCOMING_TX:
		case UserOperationType.OUTGOING_TX:
			return {
				...base,
				type: "ON-CHAIN",
				address: op.identifier,
				inbound: op.type === UserOperationType.INCOMING_TX,
				serviceFee: op.service_fee,
				...(op.internal
					? { internal: true }
					: {
						internal: false,
						networkFee: op.network_fee,
						txHash: op.tx_hash
					})
			}
		case UserOperationType.INCOMING_USER_TO_USER:
		case UserOperationType.OUTGOING_USER_TO_USER:
			return {
				...base,
				type: "USER_TO_USER",
				inbound: op.type === UserOperationType.INCOMING_USER_TO_USER,
				serviceFee: op.service_fee,
			}
		default:
			throw new Error("Unknown operation type")
	}
};





/* Pub source history fetching helpers for cursor management */
export const isAnyArrayLong = (arrays: any[][], max: number): boolean => {
	for (let i = 0; i < arrays.length; i++) {
		const array = arrays[i];
		if (array.length >= max) {
			return true
		}
	}
	return false
}

export const emptyCursor = (): HistoryCursor => ({
	latestIncomingInvoice: { ts: 0, id: 0 },
	latestIncomingTx: { ts: 0, id: 0 },
	latestIncomingUserToUserPayment: { ts: 0, id: 0 },
	latestOutgoingInvoice: { ts: 0, id: 0 },
	latestOutgoingTx: { ts: 0, id: 0 },
	latestOutgoingUserToUserPayment: { ts: 0, id: 0 },
	max_size: 10
})


export const parseOperationsResponse = (r: GetUserOperationsResponse, c: HistoryCursor) => {
	const newCursor: HistoryCursor = {
		latestIncomingInvoice: { ts: r.latestIncomingInvoiceOperations.toIndex.ts || c.latestIncomingInvoice.ts, id: r.latestIncomingInvoiceOperations.toIndex.id || c.latestIncomingInvoice.id },
		latestOutgoingInvoice: { ts: r.latestOutgoingInvoiceOperations.toIndex.ts || c.latestOutgoingInvoice.ts, id: r.latestOutgoingInvoiceOperations.toIndex.id || c.latestOutgoingInvoice.id },
		latestIncomingTx: { ts: r.latestIncomingTxOperations.toIndex.ts || c.latestIncomingTx.ts, id: r.latestIncomingTxOperations.toIndex.id || c.latestIncomingTx.id },
		latestOutgoingTx: { ts: r.latestOutgoingTxOperations.toIndex.ts || c.latestOutgoingTx.ts, id: r.latestOutgoingTxOperations.toIndex.id || c.latestOutgoingTx.id },
		latestIncomingUserToUserPayment: { ts: r.latestIncomingUserToUserPayemnts.toIndex.ts || c.latestIncomingUserToUserPayment.ts, id: r.latestIncomingUserToUserPayemnts.toIndex.id || c.latestIncomingUserToUserPayment.id },
		latestOutgoingUserToUserPayment: { ts: r.latestOutgoingUserToUserPayemnts.toIndex.ts || c.latestOutgoingUserToUserPayment.ts, id: r.latestOutgoingUserToUserPayemnts.toIndex.id || c.latestOutgoingUserToUserPayment.id },
		max_size: 10
	}

	const operations = [
		...r.latestIncomingInvoiceOperations.operations,
		...r.latestOutgoingInvoiceOperations.operations,
		...r.latestIncomingTxOperations.operations,
		...r.latestOutgoingTxOperations.operations,
		...r.latestIncomingUserToUserPayemnts.operations,
		...r.latestOutgoingUserToUserPayemnts.operations,
	]

	const needMoreData = isAnyArrayLong([
		r.latestIncomingInvoiceOperations.operations,
		r.latestOutgoingInvoiceOperations.operations,
		r.latestIncomingTxOperations.operations,
		r.latestOutgoingTxOperations.operations,
		r.latestIncomingUserToUserPayemnts.operations,
		r.latestOutgoingUserToUserPayemnts.operations,
	], 10)

	return { newCursor, operations, needMoreData }
}
