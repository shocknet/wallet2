import { NprofileView, selectHealthyNprofileViews } from "@/State/scoped/backups/sources/selectors";
import { addAppListener, AppstartListening } from "@/State/store/listenerMiddleware";
import { historyFetchAllRequested, historyFetchSourceRequested, identityLoaded, identityUnloaded } from "./actions";
import { getNostrClient } from "@/Api/nostr";
import { UserOperation } from "@/Api/pub/autogenerated/ts/types";
import { selectCursorForSource, sourcesActions } from "@/State/scoped/backups/sources/slice";
import { emptyCursor, parseOperationsResponse } from "@/State/scoped/backups/sources/history/helpers";
import { ForkedTask, TaskResult } from "@reduxjs/toolkit";
import { refreshSourceInfo } from "@/State/scoped/backups/sources/metadata/thunks";
import { Satoshi } from "@/lib/types/units";
import { AppThunk } from "@/State/store/store";
import { createDeferred } from "@/lib/deferred";



const inflightBySource = new Map<string, ForkedTask<void>>();
const subscribedLive = new Set<string>();

const MAX_PARALLEL = 10;



export const addHistorySyncer = (startListening: AppstartListening) => {

	startListening({
		actionCreator: identityLoaded,
		effect: async (_, listenerApi) => {
			listenerApi.unsubscribe();

			const unsubAll = listenerApi.dispatch(
				addAppListener({
					actionCreator: historyFetchAllRequested,
					effect: async (action, listenerApi) => {
						const views = selectHealthyNprofileViews(listenerApi.getState());
						const promises = []
						for (const v of views) {
							const deferred = createDeferred<TaskResult<void>>();
							promises.push(deferred);
							listenerApi.dispatch(historyFetchSourceRequested({ sourceId: v.sourceId, deferred }));
						}
						await Promise.allSettled(promises)
						action.payload.deferred.resolve();
					},
				})
			);

			const unsubForSource = listenerApi.dispatch(
				addAppListener({
					actionCreator: historyFetchSourceRequested,
					effect: async (action, listenerApi) => {
						const { sourceId, deferred } = action.payload;



						const existing = inflightBySource.get(sourceId);
						if (existing) {
							existing.result.then(deferred.resolve, deferred.reject) // hook deferred promise to existing ongoing task
							return;
						}


						while (inflightBySource.size >= MAX_PARALLEL) {
							// wait for any inflight to finish/cancel
							await Promise.race([...inflightBySource.values()].map(v => v.result.catch(() => { })));
						}

						const state = listenerApi.getState();
						const source = selectHealthyNprofileViews(state).find(v => v.sourceId === sourceId);
						if (!source) {
							deferred.reject(new Error(`Source not found: ${sourceId}`));
							return;
						}

						let client;
						try {
							client = await getNostrClient({ pubkey: source.lpk, relays: source.relays }, source.keys);

						} catch (err) {
							console.error(err);
							deferred.reject(err instanceof Error ? err : new Error("getNostrClient failed"));
							return;
						}




						if (!subscribedLive.has(sourceId)) {
							subscribedLive.add(sourceId);
							void listenerApi.dispatch(listenForSourceNewOperations(source));
						}


						const task = listenerApi.fork(async forkApi => {
							try {

								const infoRes = await forkApi.pause(client.GetUserInfo());

								if (infoRes.status !== "OK") throw new Error(infoRes.reason);

								if (!forkApi.signal.aborted) {
									listenerApi.dispatch(
										sourcesActions.setBalance({
											sourceId: source.sourceId,
											balance: {
												balance: infoRes.balance as Satoshi,
												maxWithdrawable: infoRes.max_withdrawable as Satoshi,
											},
										})
									);
									listenerApi.dispatch(
										sourcesActions.setNdebit({ sourceId: source.sourceId, ndebit: infoRes.ndebit })
									);
								}



								const newOps: UserOperation[] = [];

								let needMore = true;
								let populatedCursor = selectCursorForSource(listenerApi.getState(), source.sourceId) ?? emptyCursor();

								while (needMore) {
									const res = await forkApi.pause(client.GetUserOperations(populatedCursor));
									if (res.status !== "OK") throw new Error(res.reason);

									const { newCursor, operations, needMoreData } = parseOperationsResponse(res, populatedCursor);
									newOps.push(...operations);
									populatedCursor = newCursor;
									needMore = needMoreData;
								}

								if (!forkApi.signal.aborted) {
									listenerApi.dispatch(sourcesActions.mergePage({ sourceId: source.sourceId, operations: newOps, newCursor: populatedCursor }))
								}

							} catch (err) {
								deferred.reject(err instanceof Error ? err : new Error("Error when fetching history for source"));
							} finally {
								inflightBySource.delete(sourceId);
							}
						})

						inflightBySource.set(sourceId, task);

						try {
							await task.result;
							deferred.resolve();
						} catch {
							deferred.reject();
						}

					},
				})
			)

			const subForNewSources = listenerApi.dispatch(
				addAppListener({
					predicate: (action) => sourcesActions._createDraftDoc.match(action),
					effect: (action, listenerApi) => {
						const { sourceId } = action.payload;
						const deferred = createDeferred<TaskResult<void>>();
						listenerApi.dispatch(historyFetchSourceRequested({ sourceId, deferred }));
					}
				})
			)



			await listenerApi.condition(identityUnloaded.match);
			unsubAll({ cancelActive: true });
			unsubForSource({ cancelActive: true });
			subForNewSources({ cancelActive: true });
			inflightBySource.clear();
			subscribedLive.clear();
			listenerApi.subscribe();
		},
	});
};


const listenForSourceNewOperations = (source: NprofileView): AppThunk<void> => {
	return async (dispatch) => {
		const client = await getNostrClient({ pubkey: source.lpk, relays: source.relays }, source.keys);
		client.GetLiveUserOperations(newOp => {
			if (newOp.status === "OK") {
				dispatch(refreshSourceInfo(source));
				dispatch(sourcesActions.ingestLive({ sourceId: source.sourceId, operation: newOp.operation }));
			} else {
				console.error("Get live user operation error", newOp.reason)
			}
		})
	}
}
