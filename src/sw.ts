/* import { Buffer } from 'buffer';
import { nip44 } from 'nostr-tools'
import { initializeApp } from 'firebase/app';
import { getMessaging, onBackgroundMessage } from 'firebase/messaging/sw';
import type { UserOperation } from './Api/pub/autogenerated/ts/types';
import { getAllKeys, getKeys } from './State/indexedDB'; */

/* -- Precache section -- */
import { clientsClaim } from 'workbox-core'
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching'
self.skipWaiting()
clientsClaim()
precacheAndRoute(self.__WB_MANIFEST)
cleanupOutdatedCaches()
/* -- Precache section -- */

// Firebase configuration fallback for service worker
const FIREBASE_CONFIG = {
	apiKey: "AIzaSyA6YFA5tr2AHMVVXwLU00s_bVQekvXyN-w",
	authDomain: "shockwallet-11a9c.firebaseapp.com",
	projectId: "shockwallet-11a9c",
	storageBucket: "shockwallet-11a9c.firebasestorage.app",
	messagingSenderId: "73069543153",
	appId: "1:73069543153:web:048e09fb8a258acb7ab350",
	measurementId: "G-HQ89PZ3GPW"
};

// Extend ServiceWorkerGlobalScope to include the properties we need
declare let self: ServiceWorkerGlobalScope & {
	__WB_MANIFEST: any;
	registration: ServiceWorkerRegistration;
	clients: any;
	location: Location;
	addEventListener(type: string, listener: EventListener): void;
	skipWaiting: any;
};
/* if (Notification.permission === 'granted') {
	console.info('Firebase messaging service worker is set up');
	const firebaseApp = initializeApp(FIREBASE_CONFIG);
	const messaging = getMessaging(firebaseApp);

	// Handle background messages
	onBackgroundMessage(messaging, async (payload) => {
		if (!payload.data) {
			return;
		}
		const encryptedData: { encrypted: string, app_npub_hex: string } = JSON.parse(payload.data.raw)
		const keys = await getKeys(encryptedData.app_npub_hex)
		if (!keys) {
			console.log('[firebase-messaging-sw.js] No keys found for app_npub', encryptedData.app_npub_hex)
			return;
		}
		const ck = nip44.getConversationKey(Buffer.from(keys.privateKey, 'hex'), encryptedData.app_npub_hex)
		const decrypted = nip44.decrypt(encryptedData.encrypted, ck)
		const op: UserOperation = JSON.parse(decrypted)
		const notificationTitle = op.inbound ? `You received ${op.amount} sats` : `You spent ${op.amount} sats`
		const notificationOptions: NotificationOptions = {
			body: op.type,
		};

		return self.registration.showNotification(notificationTitle, notificationOptions);
	});
}


// Handle notification clicks
self.addEventListener('notificationclick', (event: any) => {
	console.log('[firebase-messaging-sw.js] Notification click received.');

	event.notification.close();

	if (event.action === 'close') {
		return;
	}

	// Default action or 'open' action
	event.waitUntil(
		self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList: any[]) => {
			// Check if there's already a window/tab open with the target URL
			for (const client of clientList) {
				if (client.url.includes(self.location.origin) && 'focus' in client) {
					return client.focus();
				}
			}

			// If no window/tab is open, open a new one
			if (self.clients.openWindow) {
				return self.clients.openWindow('/');
			}
		})
	);
});

// Handle notification close
self.addEventListener('notificationclose', (event: any) => {
	console.log('[firebase-messaging-sw.js] Notification closed:', event.notification.tag);
});


 */
